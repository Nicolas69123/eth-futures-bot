"""
Bitget Hedge Fibonacci Bot V2 - Strat√©gie avec Ordres Limites
Place automatiquement TP et ordres de doublement, g√®re les annulations
"""

import ccxt
import time
import os
from datetime import datetime
from dotenv import load_dotenv
from pathlib import Path
import requests
import hmac
import base64
import hashlib
import json
import subprocess
import sys
import logging
from collections import deque

# Import du module de commandes Telegram
from telegram_commands import TelegramCommands

# Charger .env
env_path = Path(__file__).parent.parent / '.env'
load_dotenv(dotenv_path=env_path)

# Configuration du logging
log_dir = Path(__file__).parent.parent / 'logs'
log_dir.mkdir(exist_ok=True)
log_file = log_dir / f'bot_{datetime.now().strftime("%Y%m%d")}.log'

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Buffer circulaire pour les derniers logs (pour /logs Telegram)
log_buffer = deque(maxlen=50)  # Garde les 50 derniers logs

class TelegramLogHandler(logging.Handler):
    """Handler personnalis√© pour capturer les logs dans le buffer"""
    def emit(self, record):
        log_entry = self.format(record)
        log_buffer.append(log_entry)

# Ajouter le handler au logger
telegram_handler = TelegramLogHandler()
telegram_handler.setFormatter(logging.Formatter('%(asctime)s [%(levelname)s] %(message)s'))
logger.addHandler(telegram_handler)


class HedgePosition:
    """G√®re une position hedge avec ordres limites"""

    def __init__(self, pair, initial_margin, entry_price_long, entry_price_short):
        self.pair = pair
        self.initial_margin = initial_margin
        self.entry_price_long = entry_price_long
        self.entry_price_short = entry_price_short

        # √âtat positions
        self.long_open = True
        self.short_open = True

        # Grille Fibonacci (en %) - Index 0 = Fib 0 (MARKET), 1 = Fib 1 (0.3%), etc.
        self.fib_levels = [0, 0.3, 0.382, 0.5, 0.618, 1.0, 1.618, 2.618, 4.236, 6.854, 11.09]

        # Niveaux Fibonacci S√âPAR√âS pour Long et Short
        self.long_fib_level = 0   # Long commence √† Fib 0
        self.short_fib_level = 0  # Short commence √† Fib 0

        # Tracking tailles pour d√©tecter doublements (CAS 3)
        self.long_size_previous = 0   # Sera mis √† jour apr√®s API
        self.short_size_previous = 0  # Sera mis √† jour apr√®s API

        # Tracking marges pour d√©tecter les TP (marge diminue = TP touch√©)
        self.long_margin_previous = 0   # Sera mis √† jour apr√®s API
        self.short_margin_previous = 0  # Sera mis √† jour apr√®s API

        # IDs des ordres actifs
        self.orders = {
            'tp_long': None,      # Take profit long
            'tp_short': None,     # Take profit short
            'double_short': None, # Doubler short
            'double_long': None   # Doubler long
        }

        # Stats
        self.profit_realized = 0
        self.adjustments_count = 0

    def get_next_long_trigger_pct(self):
        """Retourne le prochain niveau Fibonacci pour LONG (en %)"""
        next_level = self.long_fib_level + 1
        if next_level >= len(self.fib_levels):
            return None
        return self.fib_levels[next_level]

    def get_next_short_trigger_pct(self):
        """Retourne le prochain niveau Fibonacci pour SHORT (en %)"""
        next_level = self.short_fib_level + 1
        if next_level >= len(self.fib_levels):
            return None
        return self.fib_levels[next_level]


class BitgetHedgeBotV2:
    """Bot hedge avec syst√®me d'ordres limites automatique"""

    def __init__(self):
        # Configuration API
        self.api_key = os.getenv('BITGET_API_KEY')
        self.api_secret = os.getenv('BITGET_SECRET')
        self.api_password = os.getenv('BITGET_PASSPHRASE')

        # Debug: V√©rifier si les cl√©s sont charg√©es
        import sys
        print(f"üîë API Key charg√©e: {'‚úÖ' if self.api_key else '‚ùå'} (longueur: {len(self.api_key) if self.api_key else 0})", flush=True)
        print(f"üîë Secret charg√©: {'‚úÖ' if self.api_secret else '‚ùå'} (longueur: {len(self.api_secret) if self.api_secret else 0})", flush=True)
        print(f"üîë Passphrase charg√©e: {'‚úÖ' if self.api_password else '‚ùå'}", flush=True)
        sys.stdout.flush()

        # Telegram
        self.telegram_token = os.getenv('TELEGRAM_BOT_TOKEN')
        self.telegram_chat_id = os.getenv('TELEGRAM_CHAT_ID')

        # Exchange
        self.exchange = ccxt.bitget({
            'apiKey': self.api_key,
            'secret': self.api_secret,
            'password': self.api_password,
            'options': {
                'defaultType': 'swap',
                'defaultMarginMode': 'cross',
            },
            'headers': {'PAPTRADING': '1'},
            'enableRateLimit': True
        })

        # Paires volatiles (disponibles sur Bitget testnet)
        self.volatile_pairs = [
            'DOGE/USDT:USDT',
            'PEPE/USDT:USDT',
            'SHIB/USDT:USDT'
        ]

        self.available_pairs = self.volatile_pairs.copy()

        # Param√®tres
        self.INITIAL_MARGIN = 1  # 1‚Ç¨ de marge par position
        self.LEVERAGE = 50  # Levier x50 (max sur Bitget testnet)
        self.MAX_CAPITAL = 1000  # Capital max: 1000‚Ç¨

        # Positions actives
        self.active_positions = {}  # {pair: HedgePosition}

        # Stats
        self.total_profit = 0
        self.capital_used = 0
        self.last_status_update = time.time()

        # Historique des trades
        self.pnl_history = []  # [{timestamp, pair, pnl, action}]

        # Tracking des frais (SEULEMENT cette session)
        self.total_fees_paid = 0
        self.session_start_time = datetime.now()

        # Telegram bot (commandes)
        self.last_telegram_update_id = self.load_last_update_id()
        self.startup_time = time.time()  # Pour ignorer vieux messages au d√©marrage

        # V√©rification automatique
        self.last_health_check = time.time()
        self.health_check_interval = 60  # V√©rifier toutes les 60 secondes
        self.error_count = 0

        # Log buffer pour les commandes
        self.log_buffer = log_buffer  # R√©f√©rence au buffer global

        # Module de commandes Telegram
        self.telegram_commands = TelegramCommands(self)
        # Ne PAS d√©marrer le monitoring tout de suite - attendre apr√®s cleanup

    def load_last_update_id(self):
        """Charge le dernier update_id depuis fichier pour √©viter de retraiter les vieux messages"""
        try:
            update_id_file = Path(__file__).parent.parent / '.last_telegram_update'
            if update_id_file.exists():
                saved_id = int(update_id_file.read_text().strip())
                logger.info(f"Dernier update_id charg√©: {saved_id}")
                return saved_id
        except Exception as e:
            logger.warning(f"Impossible de charger last_update_id: {e}")
        return 0

    def save_last_update_id(self):
        """Sauvegarde le dernier update_id dans un fichier"""
        try:
            update_id_file = Path(__file__).parent.parent / '.last_telegram_update'
            update_id_file.write_text(str(self.last_telegram_update_id))
        except Exception as e:
            logger.warning(f"Impossible de sauvegarder last_update_id: {e}")

    def send_telegram(self, message):
        """Envoie message Telegram"""
        if not self.telegram_token or not self.telegram_chat_id:
            return False

        url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
        data = {
            "chat_id": self.telegram_chat_id,
            "text": message,
            "parse_mode": "HTML"
        }

        try:
            response = requests.post(url, data=data, timeout=10)
            return response.status_code == 200
        except:
            return False

    def send_detailed_position_update(self, pair, position):
        """
        Envoie des messages Telegram d√©taill√©s S√âPAR√âS pour chaque position
        Un message pour LONG, un message pour SHORT avec tous les d√©tails
        """
        try:
            # R√©cup√©rer positions r√©elles depuis API
            real_pos = self.get_real_positions(pair)
            if not real_pos:
                return

            # R√©cup√©rer les ordres ouverts
            open_orders = self.exchange.fetch_open_orders(symbol=pair)
            tpsl_orders = self.get_tpsl_orders(pair)

            # MESSAGE POUR POSITION LONG
            if real_pos.get('long'):
                long_data = real_pos['long']
                message_long = [f"üü¢ <b>POSITION LONG - {pair.split('/')[0]}</b>"]
                message_long.append("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")

                # Info position
                message_long.append(f"üìä <b>Position Actuelle:</b>")
                message_long.append(f"‚Ä¢ Contrats: {long_data['size']:.0f}")
                message_long.append(f"‚Ä¢ Entr√©e: ${long_data['entry_price']:.5f}")
                message_long.append(f"‚Ä¢ Marge: {long_data['margin']:.7f} USDT")
                message_long.append(f"‚Ä¢ PnL: {long_data['unrealized_pnl']:.7f} USDT ({long_data['pnl_percentage']:.2f}%)")
                message_long.append(f"‚Ä¢ ROE: {long_data['pnl_percentage']:.2f}%")
                message_long.append(f"‚Ä¢ Niveau Fib: {position.long_fib_level}")

                # Info TP (calcul√© par d√©faut)
                message_long.append(f"\nüéØ <b>Take Profit Long:</b>")
                TP_FIXE = 0.3
                tp_long_price = long_data['entry_price'] * (1 + TP_FIXE / 100)
                message_long.append(f"‚Ä¢ Prix TP: ${tp_long_price:.5f} (+{TP_FIXE}%)")
                message_long.append(f"‚Ä¢ Contrats: {long_data['size']:.0f}")
                message_long.append(f"‚Ä¢ Status: ‚úÖ Actif")

                # Info Double Short (Fibonacci)
                message_long.append(f"\nüìâ <b>Ordre Double Short (Fib {position.long_fib_level + 1}):</b>")
                double_short_found = False
                for order in open_orders:
                    if order.get('side') == 'sell' and order.get('type') == 'limit':
                        double_short_found = True
                        double_price = float(order.get('price', 0))
                        double_size = float(order.get('amount', 0))
                        next_margin = self.INITIAL_MARGIN * (3 ** (position.short_fib_level + 1))
                        message_long.append(f"‚Ä¢ Prix d√©clenchement: ${double_price:.5f}")
                        message_long.append(f"‚Ä¢ Distance: {((double_price - long_data['entry_price']) / long_data['entry_price'] * 100):.2f}%")
                        message_long.append(f"‚Ä¢ Contrats: {double_size:.0f}")
                        message_long.append(f"‚Ä¢ Marge pr√©vue: {next_margin:.2f} USDT")
                        break
                if not double_short_found:
                    message_long.append("‚Ä¢ ‚ö†Ô∏è Ordre non plac√©!")

                message_long.append(f"\n‚è∞ {datetime.now().strftime('%H:%M:%S')}")
                self.send_telegram("\n".join(message_long))

            # MESSAGE POUR POSITION SHORT
            if real_pos.get('short'):
                short_data = real_pos['short']
                message_short = [f"üî¥ <b>POSITION SHORT - {pair.split('/')[0]}</b>"]
                message_short.append("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")

                # Info position
                message_short.append(f"üìä <b>Position Actuelle:</b>")
                message_short.append(f"‚Ä¢ Contrats: {short_data['size']:.0f}")
                message_short.append(f"‚Ä¢ Entr√©e: ${short_data['entry_price']:.5f}")
                message_short.append(f"‚Ä¢ Marge: {short_data['margin']:.7f} USDT")
                message_short.append(f"‚Ä¢ PnL: {short_data['unrealized_pnl']:.7f} USDT ({short_data['pnl_percentage']:.2f}%)")
                message_short.append(f"‚Ä¢ ROE: {short_data['pnl_percentage']:.2f}%")
                message_short.append(f"‚Ä¢ Niveau Fib: {position.short_fib_level}")

                # Info TP
                message_short.append(f"\nüéØ <b>Take Profit Short:</b>")
                TP_FIXE = 0.3
                tp_short_price = short_data['entry_price'] * (1 - TP_FIXE / 100)
                message_short.append(f"‚Ä¢ Prix TP: ${tp_short_price:.5f} (-{TP_FIXE}%)")
                message_short.append(f"‚Ä¢ Contrats: {short_data['size']:.0f}")
                message_short.append(f"‚Ä¢ Status: ‚úÖ Actif")

                # Info Double Long (Fibonacci)
                message_short.append(f"\nüìà <b>Ordre Double Long (Fib {position.short_fib_level + 1}):</b>")
                double_long_found = False
                for order in open_orders:
                    if order.get('side') == 'buy' and order.get('type') == 'limit':
                        double_long_found = True
                        double_price = float(order.get('price', 0))
                        double_size = float(order.get('amount', 0))
                        next_margin = self.INITIAL_MARGIN * (3 ** (position.long_fib_level + 1))
                        message_short.append(f"‚Ä¢ Prix d√©clenchement: ${double_price:.5f}")
                        message_short.append(f"‚Ä¢ Distance: {((short_data['entry_price'] - double_price) / short_data['entry_price'] * 100):.2f}%")
                        message_short.append(f"‚Ä¢ Contrats: {double_size:.0f}")
                        message_short.append(f"‚Ä¢ Marge pr√©vue: {next_margin:.2f} USDT")
                        break
                if not double_long_found:
                    message_short.append("‚Ä¢ ‚ö†Ô∏è Ordre non plac√©!")

                message_short.append(f"\n‚è∞ {datetime.now().strftime('%H:%M:%S')}")
                self.send_telegram("\n".join(message_short))

        except Exception as e:
            logger.error(f"Erreur send_detailed_position_update: {e}")
            import traceback
            logger.error(traceback.format_exc())

    def get_telegram_updates(self):
        """R√©cup√®re les nouveaux messages Telegram (commandes)"""
        if not self.telegram_token:
            return []

        url = f"https://api.telegram.org/bot{self.telegram_token}/getUpdates"
        params = {'offset': self.last_telegram_update_id + 1, 'timeout': 0}

        try:
            response = requests.get(url, params=params, timeout=5)
            if response.status_code == 200:
                data = response.json()
                if data.get('ok') and data.get('result'):
                    return data['result']
        except:
            pass

        return []

    def handle_telegram_command(self, command):
        """
        Traite les commandes Telegram re√ßues
        D√©l√®gue au module telegram_commands
        """
        try:
            self.telegram_commands.process_command(command)
        except Exception as e:
            logger.error(f"Erreur traitement commande {command}: {e}")
            self.send_telegram(f"‚ùå Erreur: {e}")

    def OLD_handle_telegram_command_BACKUP(self, command):
        """BACKUP - Ancienne version des commandes"""
        if command == '/pnl':
            # Afficher P&L actuel
            total_unrealized = 0
            for pair in self.active_positions:
                real_pos = self.get_real_positions(pair)
                if real_pos:
                    if real_pos.get('long'):
                        total_unrealized += real_pos['long']['unrealized_pnl'] or 0
                    if real_pos.get('short'):
                        total_unrealized += real_pos['short']['unrealized_pnl'] or 0

            # R√©cup√©rer les VRAIS frais depuis l'API
            total_fees = self.get_total_fees()
            pnl_net = self.total_profit + total_unrealized - total_fees

            message = f"""
üí∞ <b>P&L SESSION (Donn√©es API r√©elles)</b>

üíµ P&L R√©alis√©: {self.total_profit:+.7f} USDT
üìä P&L Non R√©alis√©: {total_unrealized:+.7f} USDT
üí∏ Frais pay√©s (API): {total_fees:.7f} USDT
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üíé <b>P&L Net: {pnl_net:+.7f} USDT</b>

‚è∞ {datetime.now().strftime('%H:%M:%S')}
"""
            self.send_telegram(message)

        elif command == '/positions':
            # Afficher positions avec VRAIES donn√©es API d√©taill√©es
            message_parts = ["üìä <b>POSITIONS OUVERTES</b>\n"]

            has_positions = False
            for pair in self.volatile_pairs:
                real_pos = self.get_real_positions(pair)
                if not real_pos:
                    continue

                long_data = real_pos.get('long')
                short_data = real_pos.get('short')

                if not long_data and not short_data:
                    continue

                has_positions = True
                pair_name = pair.split('/')[0]
                current_price = self.get_price(pair)

                message_parts.append(f"\n‚îÅ‚îÅ‚îÅ‚îÅ <b>{pair_name}</b> ‚îÅ‚îÅ‚îÅ‚îÅ")
                message_parts.append(f"üí∞ Prix: ${current_price:.5f}\n")

                # LONG - EN VERT
                if long_data:
                    message_parts.append(f"üü¢ <b>LONG</b>")
                    message_parts.append(f"üü¢ Contrats: {long_data['size']:.0f}")
                    message_parts.append(f"üü¢ Entr√©e: ${long_data['entry_price']:.5f}")
                    message_parts.append(f"üü¢ Marge: {long_data['margin']:.7f} USDT")
                    message_parts.append(f"üü¢ P&L: {long_data['unrealized_pnl']:+.7f} USDT")
                    message_parts.append(f"üü¢ ROE: {long_data['pnl_percentage']:+.2f}%\n")

                # SHORT - EN ROUGE
                if short_data:
                    message_parts.append(f"üî¥ <b>SHORT</b>")
                    message_parts.append(f"üî¥ Contrats: {short_data['size']:.0f}")
                    message_parts.append(f"üî¥ Entr√©e: ${short_data['entry_price']:.5f}")
                    message_parts.append(f"üî¥ Marge: {short_data['margin']:.7f} USDT")
                    message_parts.append(f"üî¥ P&L: {short_data['unrealized_pnl']:+.7f} USDT")
                    message_parts.append(f"üî¥ ROE: {short_data['pnl_percentage']:+.2f}%")
                    if short_data.get('liquidation_price', 0) > 0:
                        message_parts.append(f"üî¥ üíÄ Liq: ${short_data['liquidation_price']:.5f}")

            if not has_positions:
                self.send_telegram("‚ö†Ô∏è Aucune position active")
                return

            message_parts.append(f"\n‚è∞ {datetime.now().strftime('%H:%M:%S')}")
            self.send_telegram("\n".join(message_parts))

        elif command == '/history':
            # Afficher historique des P&L
            if not self.pnl_history:
                self.send_telegram("üìã Aucun historique pour cette session")
                return

            message_parts = ["üìã <b>HISTORIQUE P&L</b>\n"]

            for entry in self.pnl_history[-10:]:  # 10 derniers
                timestamp = entry['timestamp'].strftime('%H:%M:%S')
                pair = entry['pair'].split('/')[0]
                pnl = entry['pnl']
                action = entry['action']

                message_parts.append(f"\n{timestamp} | {pair} | {action}: ${pnl:+.2f}")

            message_parts.append(f"\n\n‚è∞ {datetime.now().strftime('%H:%M:%S')}")
            self.send_telegram("".join(message_parts))

        elif command == '/balance':
            # Afficher balance et capital
            balance = self.MAX_CAPITAL - self.capital_used

            message = f"""
üí∞ <b>BALANCE</b>

Capital total: ${self.MAX_CAPITAL:.0f}‚Ç¨
Capital utilis√©: ${self.capital_used:.0f}‚Ç¨
Balance disponible: ${balance:.0f}‚Ç¨

üìä Utilisation: {(self.capital_used / self.MAX_CAPITAL * 100):.1f}%

‚è∞ {datetime.now().strftime('%H:%M:%S')}
"""
            self.send_telegram(message)

        elif command == '/help':
            message = """
ü§ñ <b>COMMANDES DISPONIBLES</b>

üìä <b>Trading:</b>
/pnl - P&L total de la session
/positions - Positions ouvertes
/history - Historique des 10 derniers trades
/balance - Balance et capital disponible

üîß <b>Contr√¥le:</b>
/status - √âtat du syst√®me
/admin - Commandes administrateur

/help - Liste des commandes
"""
            self.send_telegram(message)

        elif command == '/admin':
            message = """
üîê <b>COMMANDES ADMIN</b>

üîÑ /update - Mettre √† jour depuis GitHub et red√©marrer
‚ôªÔ∏è /restart - Red√©marrer le bot
üßπ /cleanup - Fermer TOUTES les positions et ordres
üîç /checkapi - V√©rifier positions r√©elles sur Bitget API
üî• /forceclose - Force fermeture avec Flash Close API
üìú /logs - Voir les derniers logs du bot
üêõ /debugrestart - Voir le log du dernier red√©marrage
‚èπÔ∏è /stop - Arr√™ter le bot (n√©cessite confirmation)
üìä /status - √âtat syst√®me d√©taill√©

‚ö†Ô∏è <b>Attention:</b> Ces commandes affectent le bot!
"""
            self.send_telegram(message)

        elif command == '/forceclose':
            self.send_telegram("üî• <b>FORCE CLOSE - Flash Close API</b>\n\nFermeture de TOUTES les positions...")
            logger.info("Commande /forceclose re√ßue")

            try:
                closed_positions = []

                for pair in self.volatile_pairs:
                    positions = self.exchange.fetch_positions(symbols=[pair])
                    for pos in positions:
                        size = float(pos.get('contracts', 0))
                        if size > 0:
                            side = pos.get('side', '').lower()

                            logger.info(f"Force Close: {side.upper()} {pair} - {size} contrats")

                            # Utiliser Flash Close API
                            success = self.flash_close_position(pair, side)

                            if success:
                                closed_positions.append(f"‚úÖ {side.upper()} {pair.split('/')[0]} ({size:.0f})")
                            else:
                                closed_positions.append(f"‚ùå √âchec {side.upper()} {pair.split('/')[0]}")

                            time.sleep(1)

                if closed_positions:
                    message = f"""
üî• <b>FORCE CLOSE TERMIN√â</b>

{chr(10).join(closed_positions)}

‚è∞ {datetime.now().strftime('%H:%M:%S')}
"""
                    self.send_telegram(message)
                else:
                    self.send_telegram("‚úÖ Aucune position √† fermer")

            except Exception as e:
                error_msg = f"‚ùå Erreur /forceclose: {e}"
                logger.error(error_msg)
                self.send_telegram(error_msg)

        elif command == '/debugrestart':
            # Lire le log du script de red√©marrage
            try:
                restart_log_path = Path('/tmp/bot_restart.log')
                if restart_log_path.exists():
                    log_content = restart_log_path.read_text()
                    # Prendre les 30 derni√®res lignes
                    log_lines = log_content.split('\n')[-30:]
                    log_text = '\n'.join(log_lines)

                    message = f"""
üêõ <b>LOG RED√âMARRAGE</b>

<pre>{log_text[:3000]}</pre>

‚è∞ {datetime.now().strftime('%H:%M:%S')}
"""
                    self.send_telegram(message)
                else:
                    self.send_telegram("üìù Aucun log de red√©marrage trouv√©.\n\nLe bot n'a jamais utilis√© /update ou /restart.")
            except Exception as e:
                self.send_telegram(f"‚ùå Erreur lecture log: {e}")

        elif command == '/cleanup':
            self.send_telegram("üßπ <b>NETTOYAGE FORC√â...</b>\n\nFermeture de toutes les positions et ordres...")
            logger.info("Commande /cleanup re√ßue - nettoyage forc√©")

            try:
                self.cleanup_all_positions_and_orders()

                # V√©rification finale apr√®s 5 secondes
                time.sleep(5)
                final_check = []
                for pair in self.volatile_pairs:
                    real_pos = self.get_real_positions(pair)
                    if real_pos:
                        if real_pos.get('long'):
                            final_check.append(f"‚ö†Ô∏è LONG {pair.split('/')[0]} encore ouvert!")
                        if real_pos.get('short'):
                            final_check.append(f"‚ö†Ô∏è SHORT {pair.split('/')[0]} encore ouvert!")

                if final_check:
                    self.send_telegram(f"‚ö†Ô∏è Positions restantes:\n{chr(10).join(final_check)}\n\nR√©essayez /cleanup ou utilisez /forceclose")
                else:
                    self.send_telegram("‚úÖ Nettoyage termin√©!\n\nToutes les positions sont ferm√©es.\n\nLe bot continue.")
            except Exception as e:
                error_msg = f"‚ùå Erreur cleanup: {e}"
                logger.error(error_msg)
                self.send_telegram(error_msg)

        elif command == '/checkapi':
            # V√©rifier positions r√©elles avec TOUTES les donn√©es API Bitget
            self.send_telegram("üîç <b>V√âRIFICATION API BITGET...</b>")

            try:
                report = ["üìä <b>POSITIONS R√âELLES (API)</b>\n"]
                has_positions = False

                for pair in self.volatile_pairs:
                    real_pos = self.get_real_positions(pair)
                    if not real_pos:
                        continue

                    long_data = real_pos.get('long')
                    short_data = real_pos.get('short')

                    if not long_data and not short_data:
                        continue

                    has_positions = True
                    pair_name = pair.split('/')[0]
                    current_price = self.get_price(pair)

                    report.append(f"\n‚îÅ‚îÅ‚îÅ‚îÅ <b>{pair_name}</b> ‚îÅ‚îÅ‚îÅ‚îÅ")
                    report.append(f"üí∞ Mark Price: ${current_price:.5f}\n")

                    # LONG - EN VERT
                    if long_data:
                        report.append(f"üü¢ <b>LONG</b>")
                        report.append(f"üü¢ Contrats: {long_data['size']:.0f}")
                        report.append(f"üü¢ Entr√©e: ${long_data['entry_price']:.5f}")
                        report.append(f"üü¢ Marge: {long_data['margin']:.7f} USDT")
                        report.append(f"üü¢ P&L: {long_data['unrealized_pnl']:+.7f} USDT")
                        report.append(f"üü¢ ROE: {long_data['pnl_percentage']:+.2f}%\n")

                    # SHORT - EN ROUGE
                    if short_data:
                        report.append(f"üî¥ <b>SHORT</b>")
                        report.append(f"üî¥ Contrats: {short_data['size']:.0f}")
                        report.append(f"üî¥ Entr√©e: ${short_data['entry_price']:.5f}")
                        report.append(f"üî¥ Marge: {short_data['margin']:.7f} USDT")
                        report.append(f"üî¥ P&L: {short_data['unrealized_pnl']:+.7f} USDT")
                        report.append(f"üî¥ ROE: {short_data['pnl_percentage']:+.2f}%")
                        liq = short_data.get('liquidation_price', 0)
                        if liq > 0:
                            report.append(f"üî¥ üíÄ Liq: ${liq:.5f}")

                if not has_positions:
                    report.append("\n‚úÖ Aucune position ouverte")

                report.append(f"\n‚è∞ {datetime.now().strftime('%H:%M:%S')}")
                self.send_telegram("\n".join(report))

            except Exception as e:
                self.send_telegram(f"‚ùå Erreur v√©rification API: {e}")

        elif command == '/logs':
            try:
                if not log_buffer:
                    self.send_telegram("üìú Aucun log disponible")
                    return

                # Prendre les 20 derniers logs
                recent_logs = list(log_buffer)[-20:]
                logs_text = "\n".join(recent_logs)

                # Tronquer si trop long (limite Telegram 4096 caract√®res)
                if len(logs_text) > 3500:
                    logs_text = logs_text[-3500:]
                    logs_text = "...\n" + logs_text

                message = f"""
üìú <b>DERNIERS LOGS</b>

<pre>{logs_text}</pre>

‚è∞ {datetime.now().strftime('%H:%M:%S')}
"""
                self.send_telegram(message)
            except Exception as e:
                self.send_telegram(f"‚ùå Erreur logs: {e}")

        elif command == '/status':
            # Status syst√®me d√©taill√©
            try:
                # Uptime du syst√®me
                uptime_result = subprocess.run(['uptime'], capture_output=True, text=True)
                uptime = uptime_result.stdout.strip() if uptime_result.returncode == 0 else "N/A"

                # M√©moire disponible
                mem_result = subprocess.run(['free', '-h'], capture_output=True, text=True)
                mem_lines = mem_result.stdout.split('\n') if mem_result.returncode == 0 else []
                mem_info = mem_lines[1] if len(mem_lines) > 1 else "N/A"

                # Git status
                git_result = subprocess.run(['git', 'rev-parse', '--short', 'HEAD'],
                                          capture_output=True, text=True, cwd=Path(__file__).parent.parent)
                git_hash = git_result.stdout.strip() if git_result.returncode == 0 else "N/A"

                message = f"""
üìä <b>STATUS SYST√àME</b>

üñ•Ô∏è <b>Serveur:</b>
{uptime}

üíæ <b>M√©moire:</b>
{mem_info}

üì¶ <b>Version:</b>
Git commit: {git_hash}

ü§ñ <b>Bot:</b>
Positions actives: {len(self.active_positions)}
Capital utilis√©: ${self.capital_used:.0f}‚Ç¨
Session d√©marr√©e: {self.session_start_time.strftime('%H:%M:%S')}

‚è∞ {datetime.now().strftime('%H:%M:%S')}
"""
                self.send_telegram(message)
            except Exception as e:
                self.send_telegram(f"‚ö†Ô∏è Erreur status: {e}")

        elif command == '/update':
            logger.info("Commande /update re√ßue")
            self.send_telegram("üîÑ <b>MISE √Ä JOUR...</b>\n\n‚ö†Ô∏è Le bot va red√©marrer.\n\nPatientez 20 secondes.")

            try:
                # Utiliser le script manage_local.sh
                manage_script = Path(__file__).parent.parent / 'manage_local.sh'

                if not manage_script.exists():
                    self.send_telegram("‚ùå Script manage_local.sh introuvable!\n\nUtilisez le raccourci Bureau √† la place.")
                    logger.error("manage_local.sh not found")
                    return

                # Lancer le script en arri√®re-plan
                logger.info("Lancement manage_local.sh update")
                subprocess.Popen(['bash', str(manage_script), 'update'],
                               stdout=subprocess.DEVNULL,
                               stderr=subprocess.DEVNULL,
                               start_new_session=True)

                logger.info("Script lanc√©, arr√™t de cette instance")
                
                sys.exit(0)  # Arr√™ter cette instance

            except Exception as e:
                error_msg = f"‚ùå Erreur /update: {e}"
                logger.error(error_msg)
                self.send_telegram(error_msg)

        elif command == '/restart':
            logger.info("Commande /restart re√ßue")
            self.send_telegram("‚ôªÔ∏è <b>RED√âMARRAGE...</b>\n\n‚ö†Ô∏è Le bot va red√©marrer.\n\nPatientez 20 secondes.")

            try:
                # Utiliser le script manage_local.sh
                manage_script = Path(__file__).parent.parent / 'manage_local.sh'

                if not manage_script.exists():
                    self.send_telegram("‚ùå Script manage_local.sh introuvable!\n\nUtilisez le raccourci Bureau.")
                    logger.error("manage_local.sh not found")
                    return

                # Lancer le script en arri√®re-plan
                logger.info("Lancement manage_local.sh restart")
                subprocess.Popen(['bash', str(manage_script), 'restart'],
                               stdout=subprocess.DEVNULL,
                               stderr=subprocess.DEVNULL,
                               start_new_session=True)

                logger.info("Script lanc√©, arr√™t de cette instance")
                
                sys.exit(0)

            except Exception as e:
                error_msg = f"‚ùå Erreur /restart: {e}"
                logger.error(error_msg)
                self.send_telegram(error_msg)

        elif command.startswith('/stop'):
            # Demander confirmation
            if command == '/stop':
                message = """
‚ö†Ô∏è <b>CONFIRMATION REQUISE</b>

√ätes-vous s√ªr de vouloir arr√™ter le bot?

Pour confirmer, envoyez:
/stop CONFIRM

Le bot sera compl√®tement arr√™t√© et devra √™tre relanc√© manuellement.
"""
                self.send_telegram(message)

            elif command == '/stop CONFIRM':
                self.send_telegram("‚èπÔ∏è <b>ARR√äT DU BOT...</b>\n\nFermeture des positions et ordres...")

                # Nettoyer avant d'arr√™ter
                self.cleanup_all_positions_and_orders()

                self.send_telegram("üõë Bot arr√™t√©.\n\nPour red√©marrer:\n- Via Telegram: /restart ou /update\n- Via Terminal: screen -S trading")

                time.sleep(2)
                subprocess.run(['screen', '-X', '-S', 'trading', 'quit'])
                sys.exit(0)

    def check_telegram_commands(self):
        """V√©rifie et traite les commandes Telegram"""
        updates = self.get_telegram_updates()

        for update in updates:
            # Mettre √† jour l'ID
            update_id = update.get('update_id', 0)
            self.last_telegram_update_id = max(self.last_telegram_update_id, update_id)

            # V√©rifier si c'est un message texte
            message = update.get('message', {})
            text = message.get('text', '')
            chat_id = message.get('chat', {}).get('id')
            message_date = message.get('date', 0)  # Timestamp Unix

            # IGNORER LES VIEUX MESSAGES AU D√âMARRAGE (plus de 5 minutes)
            message_age = time.time() - message_date
            if message_age > 300:  # 5 minutes
                logger.info(f"Message ignor√© (trop vieux): {text} (√¢ge: {message_age:.0f}s)")
                continue

            # V√©rifier que c'est bien notre chat
            if str(chat_id) == str(self.telegram_chat_id) and text.startswith('/'):
                logger.info(f"üì≤ Commande re√ßue: {text} (update_id: {update_id})")
                print(f"üì≤ Commande re√ßue: {text}")
                self.handle_telegram_command(text.strip())

        # Sauvegarder l'ID apr√®s traitement
        if updates:
            self.save_last_update_id()

    def get_price(self, symbol):
        """R√©cup√®re prix actuel"""
        try:
            ticker = self.exchange.fetch_ticker(symbol)
            return ticker['last']
        except Exception as e:
            print(f"‚ùå Erreur prix {symbol}: {e}")
            return None

    def get_real_positions(self, symbol):
        """R√©cup√®re positions r√©elles depuis API"""
        try:
            positions = self.exchange.fetch_positions(symbols=[symbol])
            result = {'long': None, 'short': None}

            for pos in positions:
                if float(pos.get('contracts', 0)) <= 0:
                    continue

                side = pos.get('side', '').lower()
                if side in ['long', 'short']:
                    result[side] = {
                        'symbol': pos['symbol'],
                        'size': float(pos['contracts']),
                        'entry_price': float(pos['entryPrice']),
                        'mark_price': float(pos['markPrice']),
                        'liquidation_price': float(pos.get('liquidationPrice') or 0),
                        'unrealized_pnl': float(pos.get('unrealizedPnl') or 0),
                        'pnl_percentage': float(pos.get('percentage') or 0),
                        'margin': float(pos.get('initialMargin') or 0),
                    }

            return result
        except Exception as e:
            print(f"‚ùå Erreur positions {symbol}: {e}")
            return None

    def format_price(self, price, pair):
        """Formate le prix selon la paire (ex: PEPE/SHIB ont besoin de plus de d√©cimales)"""
        if price == 0:
            return "$0.0000"

        # Paires √† petits prix (memecoins)
        if any(coin in pair for coin in ['PEPE', 'SHIB', 'FLOKI', 'BONK']):
            if price < 0.0001:
                return f"${price:.8f}"
            elif price < 0.01:
                return f"${price:.6f}"

        return f"${price:.4f}"

    def round_price(self, price, pair):
        """Arrondit le prix selon les r√®gles Bitget (max d√©cimales)"""
        # PEPE/SHIB/FLOKI/BONK : 8 d√©cimales max
        if any(coin in pair for coin in ['PEPE', 'SHIB', 'FLOKI', 'BONK']):
            return round(price, 8)

        # DOGE et autres : 5 d√©cimales max
        return round(price, 5)

    def verify_order_placed(self, order_id, symbol, max_retries=3):
        """
        V√©rifie qu'un ordre a bien √©t√© plac√© sur l'exchange

        Returns:
            dict: Order data si succ√®s, None si √©chec
        """
        for attempt in range(max_retries):
            try:
                  # D√©lai pour propagation
                order = self.exchange.fetch_order(order_id, symbol)

                # V√©rifier que l'ordre est bien ouvert ou rempli
                if order['status'] in ['open', 'closed']:
                    return order
                else:
                    print(f"‚ö†Ô∏è  Ordre {order_id[:8]}... statut inattendu: {order['status']}")

            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"‚ö†Ô∏è  Tentative {attempt+1}/{max_retries} v√©rification ordre: {e}")
                    time.sleep(1)
                else:
                    print(f"‚ùå √âchec v√©rification ordre {order_id[:8]}...: {e}")
                    return None

        return None

    def calculate_breakeven_tp_price(self, position, real_pos_data, direction):
        """
        Calcule le prix de TP pour position doubl√©e (utilise prix moyen)

        Args:
            position: HedgePosition object
            real_pos_data: Donn√©es r√©elles de la position depuis API
            direction: 'up' (prix a mont√©, SHORT doubl√©) ou 'down' (prix a descendu, LONG doubl√©)

        Returns:
            float: Prix du TP √† 0.3% du prix moyen, ou None si pas de donn√©es
        """
        TP_PCT = 0.3  # TP fixe √† 0.3%

        if direction == 'up':
            # Le short a √©t√© doubl√©, on veut fermer avec profit
            short_data = real_pos_data.get('short')
            if not short_data:
                logger.warning("calculate_breakeven_tp_price: Pas de donn√©es SHORT")
                return None

            # Prix moyen du short apr√®s doublement
            avg_entry = short_data.get('entry_price')
            if not avg_entry:
                logger.warning("calculate_breakeven_tp_price: entry_price SHORT manquant")
                return None

            # Pour un short, profit si prix descend ‚Üí TP √† -0.3%
            tp_price = avg_entry * (1 - TP_PCT / 100)
            return tp_price

        elif direction == 'down':
            # Le long a √©t√© doubl√©, on veut fermer avec profit
            long_data = real_pos_data.get('long')
            if not long_data:
                logger.warning("calculate_breakeven_tp_price: Pas de donn√©es LONG")
                return None

            # Prix moyen du long apr√®s doublement
            avg_entry = long_data.get('entry_price')
            if not avg_entry:
                logger.warning("calculate_breakeven_tp_price: entry_price LONG manquant")
                return None

            # Pour un long, profit si prix monte ‚Üí TP √† +0.3%
            tp_price = avg_entry * (1 + TP_PCT / 100)
            return tp_price

        return None

    def bitget_sign_request(self, timestamp, method, request_path, body=''):
        """G√©n√®re la signature pour les requ√™tes API Bitget"""
        message = str(timestamp) + method.upper() + request_path + body
        mac = hmac.new(
            self.api_secret.encode('utf-8'),
            message.encode('utf-8'),
            hashlib.sha256
        )
        return base64.b64encode(mac.digest()).decode()

    def place_tpsl_order(self, symbol, plan_type, trigger_price, hold_side, size):
        """
        Place un vrai ordre TP/SL (plan order) sur Bitget via HTTP direct

        Args:
            symbol: Paire (ex: 'DOGE/USDT:USDT')
            plan_type: 'profit_plan' (TP) ou 'loss_plan' (SL)
            trigger_price: Prix de d√©clenchement
            hold_side: 'long' ou 'short' (position √† fermer)
            size: Quantit√©

        Returns:
            dict: Order data ou None
        """
        try:
            # Convertir symbol au format Bitget (ex: DOGE/USDT:USDT ‚Üí DOGEUSDT en majuscules)
            symbol_bitget = symbol.replace('/USDT:USDT', 'USDT').replace('/', '')

            # Arrondir le prix selon les r√®gles Bitget
            trigger_price_rounded = self.round_price(trigger_price, symbol)

            # Endpoint et body
            endpoint = '/api/mix/v1/order/place-tpsl-order'
            body = {
                'symbol': symbol_bitget,
                'planType': plan_type,  # 'profit_plan' ou 'loss_plan'
                'triggerPrice': str(trigger_price_rounded),
                'triggerType': 'mark_price',
                'holdSide': hold_side,
                'size': str(round(size, 2)),  # Arrondir √† 2 d√©cimales
                'executePrice': '0'
            }
            body_json = json.dumps(body)

            # Timestamp et signature
            timestamp = str(int(time.time() * 1000))
            signature = self.bitget_sign_request(timestamp, 'POST', endpoint, body_json)

            # Headers
            headers = {
                'ACCESS-KEY': self.api_key,
                'ACCESS-SIGN': signature,
                'ACCESS-TIMESTAMP': timestamp,
                'ACCESS-PASSPHRASE': self.api_password,
                'Content-Type': 'application/json',
                'locale': 'en-US',
                'PAPTRADING': '1'
            }

            # Requ√™te HTTP
            url = f"https://api.bitget.com{endpoint}"
            response = requests.post(url, headers=headers, data=body_json, timeout=10)
            data = response.json()

            if data.get('code') == '00000':
                order_id = data.get('data', {}).get('orderId')
                print(f"‚úÖ TP/SL {plan_type} plac√©: ID {order_id}")
                return {'id': order_id, 'info': data}
            else:
                print(f"‚ùå Erreur TP/SL API: {data}")
                return None

        except Exception as e:
            print(f"‚ùå Erreur placement TP/SL: {e}")
            return None

    def get_tpsl_order_history(self, symbol, limit=100):
        """
        R√©cup√®re l'HISTORIQUE des ordres TP/SL ex√©cut√©s
        Utilise l'API V2 Bitget pour les trigger orders
        """
        try:
            symbol_bitget = symbol.replace('/USDT:USDT', 'USDT').replace('/', '').lower()

            # Endpoint pour l'historique des ordres plan (V2)
            endpoint_path = '/api/v2/mix/order/orders-plan-history'

            # R√©cup√©rer les ordres des 10 derni√®res minutes (suffisant pour TP)
            end_time = str(int(time.time() * 1000))
            start_time = str(int(time.time() * 1000) - 10 * 60 * 1000)  # 10 minutes avant

            query_params = f'?productType=USDT-FUTURES&startTime={start_time}&endTime={end_time}&pageSize={limit}'

            # Timestamp et signature
            timestamp = str(int(time.time() * 1000))
            signature = self.bitget_sign_request(timestamp, 'GET', endpoint_path + query_params, '')

            # Headers
            headers = {
                'ACCESS-KEY': self.api_key,
                'ACCESS-SIGN': signature,
                'ACCESS-TIMESTAMP': timestamp,
                'ACCESS-PASSPHRASE': self.api_password,
                'Content-Type': 'application/json',
                'locale': 'en-US',
                'PAPTRADING': '1'
            }

            # Requ√™te HTTP
            url = f"https://api.bitget.com{endpoint_path}{query_params}"
            response = requests.get(url, headers=headers, timeout=10)
            data = response.json()

            if data.get('code') == '00000':
                all_orders = data.get('data', {}).get('entrustedList', [])

                # DEBUG: Logger tous les ordres re√ßus pour voir les statuts
                logger.info(f"Historique TP/SL {symbol}: {len(all_orders)} ordres re√ßus")
                for order in all_orders[:3]:  # Logger les 3 premiers
                    logger.info(f"  Ordre: status={order.get('status')}, planType={order.get('planType')}, side={order.get('side')}")

                # Filtrer par symbol et statuts qui indiquent ex√©cution
                # Statuts possibles: 'triggered', 'executed', 'filled', 'cancelled_by_trigger'
                executed_statuses = ['triggered', 'executed', 'filled', 'cancelled_by_trigger']

                symbol_orders = [
                    o for o in all_orders
                    if o.get('symbol', '').lower() == symbol_bitget
                    and o.get('status', '') in executed_statuses
                    and o.get('planType') == 'profit_plan'  # Seulement les TP
                ]

                logger.info(f"TP ex√©cut√©s filtr√©s pour {symbol}: {len(symbol_orders)} ordres")
                return symbol_orders
            else:
                logger.warning(f"R√©ponse historique TP/SL: {data}")
                return []

        except Exception as e:
            logger.error(f"Erreur r√©cup√©ration historique TP/SL: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return []

    def check_tp_exists_via_order_detail(self, order_id, pair):
        """
        V√©rifie si un TP existe en r√©cup√©rant les d√©tails de l'ordre
        M√©thode fiable via presetStopSurplusPrice

        Args:
            order_id: ID de l'ordre TP
            pair: La paire (ex: 'DOGE/USDT:USDT')

        Returns:
            bool: True si TP existe et est actif, False sinon
        """
        try:
            if not order_id:
                return False

            logger.info(f"üîç V√©rification TP via order detail: {order_id[:8]}...")

            # Fetch order details via ccxt
            order = self.exchange.fetch_order(order_id, pair)

            # V√©rifier si ordre existe et est actif
            if order['status'] == 'open':
                # V√©rifier si presetStopSurplusPrice existe dans info
                order_info = order.get('info', {})
                preset_tp = order_info.get('presetStopSurplusPrice')

                if preset_tp:
                    logger.info(f"‚úÖ TP actif d√©tect√©: trigger @ {preset_tp}")
                    return True
                else:
                    logger.warning(f"‚ö†Ô∏è Ordre actif mais pas de preset TP trouv√©")
                    return False
            else:
                logger.info(f"‚ö†Ô∏è Ordre status: {order['status']} - TP non actif")
                return False

        except Exception as e:
            logger.error(f"Erreur v√©rification TP via order detail: {e}")
            return False

    def check_if_tp_was_executed(self, pair, side):
        """
        V√©rifie si un TP a vraiment √©t√© ex√©cut√© (pas juste position ferm√©e)
        M√©thode am√©lior√©e avec logs d√©taill√©s et v√©rification multiple

        Args:
            pair: La paire (ex: 'DOGE/USDT:USDT')
            side: 'long' ou 'short'

        Returns:
            bool: True si TP a √©t√© ex√©cut√©, False sinon
        """
        try:
            logger.info(f"üîç V√©rification TP {side.upper()} pour {pair}")

            # 1. V√©rifier dans l'historique des ordres plan
            history = self.get_tpsl_order_history(pair)

            # Chercher un TP r√©cent (dans les derni√®res 60 secondes - √©tendu de 30s)
            current_time_ms = int(time.time() * 1000)

            # TP Long = sell_single, TP Short = buy_single
            expected_side = 'sell_single' if side == 'long' else 'buy_single'

            for order in history:
                # V√©rifier si c'est un profit_plan du bon c√¥t√©
                if order.get('planType') == 'profit_plan':
                    order_side = order.get('side', '').lower()

                    if order_side == expected_side:
                        # V√©rifier si ex√©cut√© r√©cemment (60 derni√®res secondes)
                        trigger_time = int(order.get('triggerTime', 0))
                        execute_time = int(order.get('executeTime', 0))
                        check_time = trigger_time or execute_time

                        if check_time > 0 and (current_time_ms - check_time) < 60000:
                            logger.info(f"‚úÖ TP {side.upper()} confirm√© via historique")
                            logger.info(f"   Status: {order.get('status')}, Ex√©cut√© il y a {(current_time_ms - check_time) / 1000:.1f}s")
                            return True

            # 2. V√©rifier que l'ordre TP n'est plus dans les ordres pending
            pending_orders = self.get_tpsl_orders(pair)
            tp_still_pending = False

            logger.info(f"   Ordres pending: {len(pending_orders)}")

            for order in pending_orders:
                if order.get('planType') == 'profit_plan':
                    order_side = order.get('side', '').lower()
                    if order_side == expected_side:
                        tp_still_pending = True
                        logger.info(f"   TP {side.upper()} toujours pending - NIET ex√©cut√©")
                        break

            if not tp_still_pending:
                logger.info(f"‚úÖ TP {side.upper()} plus dans pending - Probablement ex√©cut√©")
                return True

            # 3. Derni√®re v√©rification: chercher dans les ordres r√©cents (fallback)
            logger.info(f"‚ö†Ô∏è TP {side.upper()} ni dans historique ni disparu du pending")
            return False

        except Exception as e:
            logger.error(f"Erreur v√©rification TP: {e}")
            import traceback
            logger.error(traceback.format_exc())
            # En cas d'erreur, retourner False pour √©viter faux positifs
            return False

    def get_tpsl_orders(self, symbol):
        """R√©cup√®re les ordres TP/SL plan en cours via HTTP direct"""
        try:
            symbol_bitget = symbol.replace('/USDT:USDT', 'USDT').replace('/', '')  # Majuscules (DOGEUSDT)

            # Endpoint (sans query params dans le path pour la signature)
            endpoint_path = '/api/v2/mix/order/orders-plan-pending'
            query_params = f'?productType=USDT-FUTURES'  # Sans planType (r√©cup√©rer tous)

            # Timestamp et signature
            timestamp = str(int(time.time() * 1000))
            signature = self.bitget_sign_request(timestamp, 'GET', endpoint_path + query_params, '')

            # Headers
            headers = {
                'ACCESS-KEY': self.api_key,
                'ACCESS-SIGN': signature,
                'ACCESS-TIMESTAMP': timestamp,
                'ACCESS-PASSPHRASE': self.api_password,
                'Content-Type': 'application/json',
                'locale': 'en-US',
                'PAPTRADING': '1'
            }

            # Requ√™te HTTP
            url = f"https://api.bitget.com{endpoint_path}{query_params}"
            response = requests.get(url, headers=headers, timeout=10)
            data = response.json()

            if data.get('code') == '00000':
                all_orders = data.get('data', {}).get('entrustedList', [])
                # Filtrer par symbol
                symbol_orders = [o for o in all_orders if o.get('symbol', '').lower() == symbol_bitget]
                return symbol_orders
            else:
                print(f"‚ö†Ô∏è R√©ponse TP/SL: {data}")
                return []

        except Exception as e:
            print(f"‚ö†Ô∏è Erreur r√©cup√©ration TP/SL: {e}")
            return []

    def get_total_fees(self):
        """
        R√©cup√®re le total R√âEL des frais pay√©s depuis le d√©marrage du bot
        Appels API UNIQUEMENT, PAS d'estimation
        """
        try:
            total_fees = 0
            fee_details = []

            # Timestamp de d√©but de session (en millisecondes)
            session_start_ms = int(self.session_start_time.timestamp() * 1000)

            logger.info(f"R√©cup√©ration frais depuis {self.session_start_time.strftime('%H:%M:%S')}")

            for pair in self.volatile_pairs:
                try:
                    # R√©cup√©rer TOUS les trades depuis le d√©but de la session
                    trades = self.exchange.fetch_my_trades(pair, since=session_start_ms, limit=500)

                    pair_fees = 0
                    for trade in trades:
                        fee = trade.get('fee', {})
                        if fee and fee.get('cost'):
                            fee_cost = float(fee['cost'])
                            total_fees += fee_cost
                            pair_fees += fee_cost

                    if pair_fees > 0:
                        logger.info(f"Frais {pair.split('/')[0]}: {pair_fees:.7f} USDT ({len(trades)} trades)")
                        fee_details.append(f"{pair.split('/')[0]}: {pair_fees:.7f}")

                except Exception as e:
                    logger.warning(f"Impossible de r√©cup√©rer frais pour {pair}: {e}")

            logger.info(f"Total frais session: {total_fees:.7f} USDT")
            return total_fees

        except Exception as e:
            logger.error(f"Erreur get_total_fees: {e}")
            return 0

    def set_leverage(self, symbol, leverage):
        """Configure le levier"""
        try:
            self.exchange.set_leverage(leverage, symbol)
            print(f"‚öôÔ∏è  Levier x{leverage} configur√©")
            return True
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur levier: {e}")
            return False

    def set_position_mode(self, symbol):
        """Active mode hedge"""
        try:
            self.exchange.set_position_mode(hedged=True, symbol=symbol)
            print(f"‚öôÔ∏è  Mode hedge activ√©")
            return True
        except Exception as e:
            print(f"‚ö†Ô∏è  Mode hedge: {e}")
            return False

    def cancel_order(self, order_id, symbol):
        """Annule un ordre (LIMIT ou TP/SL plan) avec logging d√©taill√©"""
        if not order_id:
            logger.warning(f"Tentative annulation ordre None sur {symbol}")
            return True

        logger.info(f"Annulation ordre {order_id[:12]}... sur {symbol}")

        # Essayer d'annuler comme ordre LIMIT standard
        try:
            self.exchange.cancel_order(order_id, symbol)
            logger.info(f"‚úÖ Ordre LIMIT {order_id[:12]}... annul√©")
            print(f"üóëÔ∏è  Ordre LIMIT {order_id[:8]}... annul√©")
            return True
        except Exception as e:
            error_msg = str(e)
            # Si ordre n'existe pas comme LIMIT, essayer comme TP/SL plan
            if '40768' in error_msg or 'does not exist' in error_msg.lower():
                logger.info(f"Ordre pas trouv√© comme LIMIT, essai comme TP/SL plan...")
                # Essayer d'annuler comme TP/SL plan
                try:
                    result = self.cancel_tpsl_order(order_id, symbol)
                    if result:
                        logger.info(f"‚úÖ Ordre TP/SL {order_id[:12]}... annul√©")
                    return result
                except:
                    logger.info(f"‚ÑπÔ∏è Ordre {order_id[:12]}... d√©j√† ex√©cut√©/annul√©")
                    print(f"‚ÑπÔ∏è  Ordre {order_id[:8]}... d√©j√† ex√©cut√©/annul√©")
                    return True
            else:
                logger.error(f"‚ö†Ô∏è Erreur annulation {order_id[:12]}: {e}")
                print(f"‚ö†Ô∏è  Erreur annulation: {e}")
                return False

    def cancel_tpsl_order(self, order_id, symbol):
        """Annule un ordre TP/SL plan"""
        try:
            symbol_bitget = symbol.replace('/USDT:USDT', 'USDT').replace('/', '')  # Majuscules (DOGEUSDT)

            endpoint = '/api/v2/mix/order/cancel-plan-order'
            body = {
                'productType': 'USDT-FUTURES',  # Majuscules
                'symbol': symbol_bitget,
                'marginCoin': 'USDT',
                'orderId': order_id,
                'planType': 'pos_profit'  # pos_profit au lieu de profit_plan
            }
            body_json = json.dumps(body)

            timestamp = str(int(time.time() * 1000))
            signature = self.bitget_sign_request(timestamp, 'POST', endpoint, body_json)

            headers = {
                'ACCESS-KEY': self.api_key,
                'ACCESS-SIGN': signature,
                'ACCESS-TIMESTAMP': timestamp,
                'ACCESS-PASSPHRASE': self.api_password,
                'Content-Type': 'application/json',
                'locale': 'en-US',
                'PAPTRADING': '1'
            }

            url = f"https://api.bitget.com{endpoint}"
            response = requests.post(url, headers=headers, data=body_json, timeout=10)
            data = response.json()

            if data.get('code') == '00000':
                print(f"üóëÔ∏è  TP/SL {order_id[:8]}... annul√©")
                return True
            else:
                print(f"‚ö†Ô∏è Erreur annulation TP/SL: {data}")
                return False

        except Exception as e:
            print(f"‚ö†Ô∏è Erreur annulation TP/SL: {e}")
            return False

    def open_hedge_with_limit_orders(self, pair):
        """
        Ouvre hedge + Place imm√©diatement les 4 ordres limites
        """
        if self.capital_used + (self.INITIAL_MARGIN * 2) > self.MAX_CAPITAL:
            print(f"‚ö†Ô∏è  Capital max atteint")
            return False

        print(f"\n{'='*80}")
        print(f"üéØ OUVERTURE HEDGE: {pair}")
        print(f"{'='*80}")

        # Configuration
        self.set_position_mode(pair)
        self.set_leverage(pair, self.LEVERAGE)

        price = self.get_price(pair)
        if not price:
            return False

        notional = self.INITIAL_MARGIN * self.LEVERAGE
        size = notional / price

        try:
            # 1. Ouvrir Long et Short en MARKET
            print("\n1Ô∏è‚É£ Ouverture positions MARKET...")

            long_order = self.exchange.create_order(
                symbol=pair, type='market', side='buy', amount=size,
                params={'tradeSide': 'open', 'holdSide': 'long'}
            )
            print(f"‚úÖ Long ouvert: {size:.4f}")

            short_order = self.exchange.create_order(
                symbol=pair, type='market', side='sell', amount=size,
                params={'tradeSide': 'open', 'holdSide': 'short'}
            )
            print(f"‚úÖ Short ouvert: {size:.4f}")

            time.sleep(2)  # Attendre ex√©cution

            # R√©cup√©rer vraies positions
            real_pos = self.get_real_positions(pair)
            if not real_pos or not real_pos.get('long') or not real_pos.get('short'):
                print("‚ùå Impossible de r√©cup√©rer positions")
                return False

            entry_long = real_pos['long']['entry_price']
            entry_short = real_pos['short']['entry_price']

            print(f"üìä Prix entr√©e Long (API): {self.format_price(entry_long, pair)}")
            print(f"üìä Prix entr√©e Short (API): {self.format_price(entry_short, pair)}")

            # Cr√©er position tracking
            position = HedgePosition(pair, self.INITIAL_MARGIN, entry_long, entry_short)

            # Stocker tailles initiales pour d√©tection doublements (CAS 3)
            position.long_size_previous = real_pos['long']['size']
            position.short_size_previous = real_pos['short']['size']

            self.active_positions[pair] = position

            # Attendre 3s avant de placer les TP (Bitget refuse si trop rapide)
            print("\n‚è≥ Attente 3s avant placement TP...")
            time.sleep(3)

            # 2. Placer les 4 ordres limites avec v√©rification
            print("\n2Ô∏è‚É£ Placement des 4 ordres limites...")

            # Niveau initial = Fib 1 (0.3%) pour TOUS les ordres
            next_trigger_pct = position.fib_levels[1]  # Fib 1 = 0.3%

            # R√©cup√©rer le prix actuel du march√© MAINTENANT
            current_market_price = self.get_price(pair)

            print(f"\nüîç DEBUG PLACEMENT ORDRES:")
            print(f"   Prix entr√©e Long (API): {self.format_price(entry_long, pair)}")
            print(f"   Prix entr√©e Short (API): {self.format_price(entry_short, pair)}")
            print(f"   Prix march√© ACTUEL: {self.format_price(current_market_price, pair)}")
            print(f"   Variation depuis entr√©e: {((current_market_price - entry_long) / entry_long * 100):+.4f}%")

            # Calculer prix des triggers
            tp_long_price = entry_long * (1 + next_trigger_pct / 100)
            tp_short_price = entry_short * (1 - next_trigger_pct / 100)
            double_short_price = tp_long_price  # M√äME PRIX que TP Long
            double_long_price = tp_short_price  # M√äME PRIX que TP Short

            print(f"\n   Ordres qui vont √™tre plac√©s:")
            print(f"   TP Long @ {self.format_price(tp_long_price, pair)} (+{next_trigger_pct}%)")
            print(f"   TP Short @ {self.format_price(tp_short_price, pair)} (-{next_trigger_pct}%)")
            print(f"   Distance TP Long: {((tp_long_price - current_market_price) / current_market_price * 100):+.4f}%")
            print(f"   Distance TP Short: {((tp_short_price - current_market_price) / current_market_price * 100):+.4f}%")

            # a) TP Long (VRAI ordre TP/SL Bitget)
            try:
                tp_long_order = self.place_tpsl_order(
                    symbol=pair,
                    plan_type='profit_plan',
                    trigger_price=tp_long_price,
                    hold_side='long',
                    size=size
                )
                if tp_long_order and tp_long_order.get('id'):
                    position.orders['tp_long'] = tp_long_order['id']
                    print(f"‚úÖ TP Long (VRAI TP) @ {self.format_price(tp_long_price, pair)} (+{next_trigger_pct}%)")
                else:
                    print(f"‚ùå √âchec placement TP Long")
                    return False
            except Exception as e:
                print(f"‚ùå Erreur TP Long: {e}")
                return False

            # b) Doubler Short (si prix monte - M√äME PRIX)
            try:
                double_short_order = self.exchange.create_order(
                    symbol=pair, type='limit', side='sell', amount=size * 2, price=double_short_price,
                    params={'tradeSide': 'open', 'holdSide': 'short'}  # Ouvrir SHORT
                )
                verified = self.verify_order_placed(double_short_order['id'], pair)
                if verified:
                    position.orders['double_short'] = double_short_order['id']
                    print(f"‚úÖ Doubler Short @ {self.format_price(double_short_price, pair)}")
                else:
                    print(f"‚ùå √âchec placement Doubler Short")
                    return False
            except Exception as e:
                print(f"‚ùå Erreur Doubler Short: {e}")
                return False

            # c) TP Short (VRAI ordre TP/SL Bitget)
            try:
                tp_short_order = self.place_tpsl_order(
                    symbol=pair,
                    plan_type='profit_plan',
                    trigger_price=tp_short_price,
                    hold_side='short',
                    size=size
                )
                if tp_short_order and tp_short_order.get('id'):
                    position.orders['tp_short'] = tp_short_order['id']
                    print(f"‚úÖ TP Short (VRAI TP) @ {self.format_price(tp_short_price, pair)} (-{next_trigger_pct}%)")
                else:
                    print(f"‚ùå √âchec placement TP Short")
                    return False
            except Exception as e:
                print(f"‚ùå Erreur TP Short: {e}")
                return False

            # d) Doubler Long (si prix descend - M√äME PRIX)
            try:
                double_long_order = self.exchange.create_order(
                    symbol=pair, type='limit', side='buy', amount=size * 2, price=double_long_price,
                    params={'tradeSide': 'open', 'holdSide': 'long'}  # Ouvrir LONG
                )
                verified = self.verify_order_placed(double_long_order['id'], pair)
                if verified:
                    position.orders['double_long'] = double_long_order['id']
                    print(f"‚úÖ Doubler Long @ {self.format_price(double_long_price, pair)}")
                else:
                    print(f"‚ùå √âchec placement Doubler Long")
                    return False
            except Exception as e:
                print(f"‚ùå Erreur Doubler Long: {e}")
                return False

            self.capital_used += self.INITIAL_MARGIN * 2
            self.available_pairs.remove(pair)

            # Envoyer les messages d√©taill√©s s√©par√©s pour chaque position
            self.send_detailed_position_update(pair, position)

            return True

        except Exception as e:
            print(f"‚ùå Erreur ouverture: {e}")
            return False

    def detect_fib_level_from_margin(self, margin):
        """D√©tecte niveau Fibonacci depuis marge (1‚Üí3‚Üí9‚Üí27‚Üí81 USDT)"""
        if margin < 2:
            return 0
        elif margin < 6:
            return 1
        elif margin < 18:
            return 2
        elif margin < 54:
            return 3
        elif margin < 162:
            return 4
        else:
            return 5

    def place_orders_for_long(self, pair, position, long_data):
        """RATTRAPAGE: Place TP + Double pour Long"""
        size_long = long_data['size']
        entry_long = long_data['entry_price']

        next_level = position.long_fib_level + 1
        if next_level >= len(position.fib_levels):
            return

        next_pct = position.fib_levels[next_level]

        # TP 0.3% fixe, Double niveau Fib
        tp_price = entry_long * 1.003
        double_price = entry_long * (1 - next_pct / 100)

        # TP Long
        if not position.orders['tp_long']:
            try:
                tp = self.place_tpsl_order(pair, 'profit_plan', tp_price, 'long', size_long)
                if tp and tp.get('id'):
                    position.orders['tp_long'] = tp['id']
                    logger.info(f"üîß RATTRAPAGE TP Long @ {self.format_price(tp_price, pair)}")
            except Exception as e:
                logger.error(f"Rattrapage TP Long: {e}")

        # Double Long
        if not position.orders['double_long']:
            try:
                double = self.exchange.create_order(
                    pair, 'limit', 'buy', size_long * 2, double_price,
                    params={'tradeSide': 'open', 'holdSide': 'long'}
                )
                if double and double.get('id'):
                    position.orders['double_long'] = double['id']
                    logger.info(f"üîß RATTRAPAGE Double Long @ {self.format_price(double_price, pair)}")
            except Exception as e:
                logger.error(f"Rattrapage Double Long: {e}")

    def place_orders_for_short(self, pair, position, short_data):
        """RATTRAPAGE: Place TP + Double pour Short"""
        size_short = short_data['size']
        entry_short = short_data['entry_price']

        next_level = position.short_fib_level + 1
        if next_level >= len(position.fib_levels):
            return

        next_pct = position.fib_levels[next_level]

        # TP 0.3% fixe, Double niveau Fib
        tp_price = entry_short * 0.997
        double_price = entry_short * (1 + next_pct / 100)

        # TP Short
        if not position.orders['tp_short']:
            try:
                tp = self.place_tpsl_order(pair, 'profit_plan', tp_price, 'short', size_short)
                if tp and tp.get('id'):
                    position.orders['tp_short'] = tp['id']
                    logger.info(f"üîß RATTRAPAGE TP Short @ {self.format_price(tp_price, pair)}")
            except Exception as e:
                logger.error(f"Rattrapage TP Short: {e}")

        # Double Short
        if not position.orders['double_short']:
            try:
                double = self.exchange.create_order(
                    pair, 'limit', 'sell', size_short * 2, double_price,
                    params={'tradeSide': 'open', 'holdSide': 'short'}
                )
                if double and double.get('id'):
                    position.orders['double_short'] = double['id']
                    logger.info(f"üîß RATTRAPAGE Double Short @ {self.format_price(double_price, pair)}")
            except Exception as e:
                logger.error(f"Rattrapage Double Short: {e}")

    def verify_and_fix_missing_orders(self, pair, position):
        """
        RATTRAPAGE COMPLET: V√©rifie ordres R√âELS sur API Bitget
        Compare avec m√©moire, replace si manquants ou invalides
        """
        try:
            real_pos = self.get_real_positions(pair)
            if not real_pos:
                return

            long_data = real_pos.get('long')
            short_data = real_pos.get('short')

            # D√©tecter + corriger niveaux Fib
            if long_data:
                detected = self.detect_fib_level_from_margin(long_data['margin'])
                if detected != position.long_fib_level:
                    logger.info(f"üîÑ LONG Fib: {position.long_fib_level} ‚Üí {detected}")
                    position.long_fib_level = detected

            if short_data:
                detected = self.detect_fib_level_from_margin(short_data['margin'])
                if detected != position.short_fib_level:
                    logger.info(f"üîÑ SHORT Fib: {position.short_fib_level} ‚Üí {detected}")
                    position.short_fib_level = detected

            # V√âRIFIER ORDRES R√âELS SUR L'API BITGET (pas juste m√©moire)
            try:
                # Ordres LIMIT (Double Long/Short)
                limit_orders = self.exchange.fetch_open_orders(symbol=pair)
                limit_order_ids = [o['id'] for o in limit_orders]

                # Ordres TP/SL plan
                tpsl_orders = self.get_tpsl_orders(pair)
                tpsl_order_ids = [o.get('planId') or o.get('orderId') for o in tpsl_orders] if tpsl_orders else []

            except Exception as e:
                logger.error(f"Erreur r√©cup√©ration ordres API: {e}")
                return

            # V√©rifier chaque ordre stock√© vs API r√©elle
            missing = []

            if long_data:
                tp_long_id = position.orders.get('tp_long')
                if not tp_long_id or tp_long_id not in tpsl_order_ids:
                    missing.append('tp_long')
                    position.orders['tp_long'] = None  # Reset m√©moire

                double_long_id = position.orders.get('double_long')
                if not double_long_id or double_long_id not in limit_order_ids:
                    missing.append('double_long')
                    position.orders['double_long'] = None  # Reset m√©moire

            if short_data:
                tp_short_id = position.orders.get('tp_short')
                if not tp_short_id or tp_short_id not in tpsl_order_ids:
                    missing.append('tp_short')
                    position.orders['tp_short'] = None  # Reset m√©moire

                double_short_id = position.orders.get('double_short')
                if not double_short_id or double_short_id not in limit_order_ids:
                    missing.append('double_short')
                    position.orders['double_short'] = None  # Reset m√©moire

            # DEBUG: Afficher √©tat
            logger.info(f"[RATTRAPAGE] Ordres API r√©els: LIMIT={len(limit_order_ids)}, TPSL={len(tpsl_order_ids)}")

            # Replacer si manquants
            if missing:
                logger.warning(f"‚ö†Ô∏è {pair}: {len(missing)} ordres manquants/invalides: {missing}")
                print(f"üîß RATTRAPAGE {pair}: {missing}")

                if 'tp_long' in missing or 'double_long' in missing:
                    logger.info(f"Replacement ordres LONG...")
                    self.place_orders_for_long(pair, position, long_data)

                if 'tp_short' in missing or 'double_short' in missing:
                    logger.info(f"Replacement ordres SHORT...")
                    self.place_orders_for_short(pair, position, short_data)

        except Exception as e:
            logger.error(f"Erreur verify_and_fix: {e}")
            import traceback
            logger.error(traceback.format_exc())

    def handle_tp_long_executed(self, pair, position):
        """
        ‚úÖ √âV√âNEMENT 1: TP LONG EX√âCUT√â

        Actions (4 seulement):
        1. Annuler FIBO LONG (l'ordre LIMIT de doublement)
        2. R√©ouvrir Long en MARKET
        3. Placer NOUVEAU TP Long
        4. Placer NOUVEAU FIBO Long (Fib 1)
        """
        print(f"\nüîî HANDLE_TP_LONG_EXECUTED START - {pair}")
        logger.info(f"üîî TP LONG EX√âCUT√â - {pair}")

        try:
            # ‚úÖ 1. Annuler FIBO LONG (double_long LIMIT)
            print(f"   [1/4] Annuler Double Long LIMIT...")
            if position.orders.get('double_long'):
                order_id = position.orders['double_long']
                print(f"       Order ID: {order_id}")
                result = self.cancel_order(order_id, pair)
                print(f"       R√©sultat: {result}")
                position.orders['double_long'] = None
                logger.info(f"   ‚úì Annul√© Double Long LIMIT: {order_id}")
            else:
                print(f"       ‚ö†Ô∏è Pas d'ordre double_long trouv√©!")
                logger.warning(f"   ‚ö†Ô∏è Pas d'ordre double_long pour annuler")

            # ‚úÖ 2. R√©ouvrir Long en MARKET
            print(f"   [2/4] R√©ouvrir Long MARKET...")
            current_price = self.get_price(pair)
            print(f"       Prix: {current_price}")
            notional = self.INITIAL_MARGIN * self.LEVERAGE
            size_long = notional / current_price
            print(f"       Size: {size_long}")

            try:
                long_order = self.exchange.create_order(
                    symbol=pair, type='market', side='buy', amount=size_long,
                    params={'tradeSide': 'open', 'holdSide': 'long'}
                )
                print(f"       ‚úì Ordre cr√©√©: {long_order.get('id')}")
                logger.info(f"   ‚úì R√©ouvert Long MARKET @ {self.format_price(current_price, pair)}")
            except Exception as e:
                print(f"       ‚ùå ERREUR cr√©er ordre: {e}")
                logger.error(f"   ‚ùå Erreur cr√©ation ordre MARKET: {e}")
                return

            # Attendre puis r√©cup√©rer position r√©elle
            print(f"   [2bis] Attente 2s + r√©cup√©ration position...")
            time.sleep(2)
            real_pos = self.get_real_positions(pair)
            print(f"       Real pos: {real_pos}")

            if not real_pos or not real_pos.get('long'):
                print(f"       ‚ùå Impossible de r√©cup√©rer Long apr√®s r√©ouverture")
                logger.error(f"‚ùå Impossible de r√©cup√©rer Long apr√®s r√©ouverture")
                return

            entry_long = real_pos['long']['entry_price']
            size_long_real = real_pos['long']['size']
            print(f"       Entry: {entry_long}, Size: {size_long_real}")

            position.entry_price_long = entry_long
            position.long_open = True
            position.long_fib_level = 0
            position.long_margin_previous = real_pos['long']['margin']

            # ‚úÖ 3. Placer NOUVEAU TP Long (0.3% fixe)
            print(f"   [3/4] Placer NOUVEAU TP Long...")
            time.sleep(1)
            TP_FIXE = 0.3
            tp_long_price = entry_long * (1 + TP_FIXE / 100)
            print(f"       TP Price: {tp_long_price}")

            tp_order = self.place_tpsl_order(
                symbol=pair,
                plan_type='profit_plan',
                trigger_price=tp_long_price,
                hold_side='long',
                size=size_long_real
            )
            print(f"       TP Order Result: {tp_order}")

            if tp_order and tp_order.get('id'):
                position.orders['tp_long'] = tp_order['id']
                print(f"       ‚úì TP Long cr√©√©: {tp_order.get('id')}")
                logger.info(f"   ‚úì Nouveau TP Long @ {self.format_price(tp_long_price, pair)} (+{TP_FIXE}%)")
            else:
                print(f"       ‚ö†Ô∏è TP Long √©chou√©!")

            # ‚úÖ 4. Placer NOUVEAU FIBO Long (Fib 1 = 0.3%)
            print(f"   [4/4] Placer NOUVEAU FIBO Long...")
            time.sleep(1)
            next_pct = position.fib_levels[1]
            fibo_long_price = entry_long * (1 - next_pct / 100)
            print(f"       Fibo Price: {fibo_long_price}")

            try:
                fibo_order = self.exchange.create_order(
                    symbol=pair, type='limit', side='buy', amount=size_long_real * 2,
                    price=fibo_long_price, params={'tradeSide': 'open', 'holdSide': 'long'}
                )
                print(f"       Fibo Order: {fibo_order}")

                if fibo_order and fibo_order.get('id'):
                    position.orders['double_long'] = fibo_order['id']
                    print(f"       ‚úì Fibo Long cr√©√©: {fibo_order.get('id')}")
                    logger.info(f"   ‚úì Nouveau Fibo Long @ {self.format_price(fibo_long_price, pair)} (-{next_pct}%, Fib 1)")
            except Exception as e:
                print(f"       ‚ùå ERREUR Fibo: {e}")
                logger.error(f"   ‚ùå Erreur Fibo Long: {e}")

            position.long_size_previous = size_long_real
            print(f"üîî HANDLE_TP_LONG_EXECUTED DONE\n")

        except Exception as e:
            print(f"‚ùå EXCEPTION handle_tp_long_executed: {e}")
            logger.error(f"‚ùå Erreur handle_tp_long_executed: {e}")
            import traceback
            logger.error(traceback.format_exc())
            print(traceback.format_exc())

    def handle_tp_short_executed(self, pair, position):
        """
        ‚úÖ √âV√âNEMENT 2: TP SHORT EX√âCUT√â

        Actions (4 seulement):
        1. Annuler FIBO SHORT (l'ordre LIMIT de doublement)
        2. R√©ouvrir Short en MARKET
        3. Placer NOUVEAU TP Short
        4. Placer NOUVEAU FIBO Short (Fib 1)
        """
        logger.info(f"üîî TP SHORT EX√âCUT√â - {pair}")

        try:
            # ‚úÖ 1. Annuler FIBO SHORT (double_short LIMIT)
            if position.orders.get('double_short'):
                self.cancel_order(position.orders['double_short'], pair)
                position.orders['double_short'] = None
                logger.info(f"   ‚úì Annul√© Double Short LIMIT")

            # ‚úÖ 2. R√©ouvrir Short en MARKET
            current_price = self.get_price(pair)
            notional = self.INITIAL_MARGIN * self.LEVERAGE
            size_short = notional / current_price

            short_order = self.exchange.create_order(
                symbol=pair, type='market', side='sell', amount=size_short,
                params={'tradeSide': 'open', 'holdSide': 'short'}
            )
            logger.info(f"   ‚úì R√©ouvert Short MARKET @ {self.format_price(current_price, pair)}")

            # Attendre puis r√©cup√©rer position r√©elle
            time.sleep(2)
            real_pos = self.get_real_positions(pair)
            if not real_pos or not real_pos.get('short'):
                logger.error(f"‚ùå Impossible de r√©cup√©rer Short apr√®s r√©ouverture")
                return

            entry_short = real_pos['short']['entry_price']
            size_short_real = real_pos['short']['size']
            position.entry_price_short = entry_short
            position.short_open = True
            position.short_fib_level = 0  # R√©initialis√© √† Fib 0
            position.short_margin_previous = real_pos['short']['margin']  # Mettre √† jour marge

            # ‚úÖ 3. Placer NOUVEAU TP Short (0.3% fixe)
            time.sleep(1)
            TP_FIXE = 0.3
            tp_short_price = entry_short * (1 - TP_FIXE / 100)

            tp_order = self.place_tpsl_order(
                symbol=pair,
                plan_type='profit_plan',
                trigger_price=tp_short_price,
                hold_side='short',
                size=size_short_real
            )
            if tp_order and tp_order.get('id'):
                position.orders['tp_short'] = tp_order['id']
                logger.info(f"   ‚úì Nouveau TP Short @ {self.format_price(tp_short_price, pair)} (-{TP_FIXE}%)")

            # ‚úÖ 4. Placer NOUVEAU FIBO Short (Fib 1 = 0.3%)
            time.sleep(1)
            next_pct = position.fib_levels[1]  # Fib 1 = 0.3%
            fibo_short_price = entry_short * (1 + next_pct / 100)

            fibo_order = self.exchange.create_order(
                symbol=pair, type='limit', side='sell', amount=size_short_real * 2,
                price=fibo_short_price, params={'tradeSide': 'open', 'holdSide': 'short'}
            )
            if fibo_order and fibo_order.get('id'):
                position.orders['double_short'] = fibo_order['id']
                logger.info(f"   ‚úì Nouveau Fibo Short @ {self.format_price(fibo_short_price, pair)} (+{next_pct}%, Fib 1)")

            position.short_size_previous = size_short_real

        except Exception as e:
            logger.error(f"‚ùå Erreur handle_tp_short_executed: {e}")
            import traceback
            logger.error(traceback.format_exc())

    def handle_fib_long_executed(self, pair, position, size_before, size_after):
        """
        ‚úÖ √âV√âNEMENT 3: FIBO LONG EX√âCUT√â

        Actions (4 seulement):
        1. Annuler TP LONG + Double LONG (ordres anciens)
        2. Augmenter Fib level (+1)
        3. Placer NOUVEAU TP Long (au prix moyen)
        4. Placer NOUVEAU Fibo Long (niveau suivant)
        """
        logger.info(f"‚ö° FIBO LONG EX√âCUT√â: {size_before:.0f} ‚Üí {size_after:.0f} contrats")

        try:
            # ‚úÖ 1. Annuler TP LONG + Double LONG (ordres anciens)
            if position.orders.get('tp_long'):
                self.cancel_order(position.orders['tp_long'], pair)
                position.orders['tp_long'] = None
                logger.info(f"   ‚úì Annul√© TP Long")

            if position.orders.get('double_long'):
                self.cancel_order(position.orders['double_long'], pair)
                position.orders['double_long'] = None
                logger.info(f"   ‚úì Annul√© Double Long")

            # R√©cup√©rer position r√©elle depuis API
            real_pos = self.get_real_positions(pair)
            if not real_pos or not real_pos.get('long'):
                logger.error(f"‚ùå Long data manquant apr√®s doublement")
                return

            entry_long_moyen = real_pos['long']['entry_price']
            size_long_total = real_pos['long']['size']

            # ‚úÖ 2. Augmenter Fib level (+1)
            position.long_fib_level += 1
            position.entry_price_long = entry_long_moyen
            logger.info(f"   ‚úì Fib level: {position.long_fib_level - 1} ‚Üí {position.long_fib_level}")

            # ‚úÖ 3. Placer NOUVEAU TP Long (0.3% fixe au prix moyen)
            time.sleep(1)
            TP_FIXE = 0.3
            tp_long_price = entry_long_moyen * (1 + TP_FIXE / 100)

            tp_order = self.place_tpsl_order(
                symbol=pair,
                plan_type='profit_plan',
                trigger_price=tp_long_price,
                hold_side='long',
                size=size_long_total
            )
            if tp_order and tp_order.get('id'):
                position.orders['tp_long'] = tp_order['id']
                logger.info(f"   ‚úì Nouveau TP Long @ {self.format_price(tp_long_price, pair)} (+{TP_FIXE}%, {size_long_total:.0f} contrats)")

            # ‚úÖ 4. Placer NOUVEAU Fibo Long (niveau suivant)
            time.sleep(1)
            next_level = position.long_fib_level + 1
            if next_level < len(position.fib_levels):
                next_pct = position.fib_levels[next_level]
                fibo_long_price = entry_long_moyen * (1 - next_pct / 100)

                fibo_order = self.exchange.create_order(
                    symbol=pair, type='limit', side='buy', amount=size_long_total * 2,
                    price=fibo_long_price, params={'tradeSide': 'open', 'holdSide': 'long'}
                )
                if fibo_order and fibo_order.get('id'):
                    position.orders['double_long'] = fibo_order['id']
                    logger.info(f"   ‚úì Nouveau Fibo Long @ {self.format_price(fibo_long_price, pair)} (-{next_pct}%, Fib {next_level})")

            position.long_size_previous = size_long_total

        except Exception as e:
            logger.error(f"‚ùå Erreur handle_fib_long_executed: {e}")
            import traceback
            logger.error(traceback.format_exc())

    def handle_fib_short_executed(self, pair, position, size_before, size_after):
        """
        ‚úÖ √âV√âNEMENT 4: FIBO SHORT EX√âCUT√â

        Actions (4 seulement):
        1. Annuler TP SHORT + Double SHORT (ordres anciens)
        2. Augmenter Fib level (+1)
        3. Placer NOUVEAU TP Short (au prix moyen)
        4. Placer NOUVEAU Fibo Short (niveau suivant)
        """
        logger.info(f"‚ö° FIBO SHORT EX√âCUT√â: {size_before:.0f} ‚Üí {size_after:.0f} contrats")

        try:
            # ‚úÖ 1. Annuler TP SHORT + Double SHORT (ordres anciens)
            if position.orders.get('tp_short'):
                self.cancel_order(position.orders['tp_short'], pair)
                position.orders['tp_short'] = None
                logger.info(f"   ‚úì Annul√© TP Short")

            if position.orders.get('double_short'):
                self.cancel_order(position.orders['double_short'], pair)
                position.orders['double_short'] = None
                logger.info(f"   ‚úì Annul√© Double Short")

            # R√©cup√©rer position r√©elle depuis API
            real_pos = self.get_real_positions(pair)
            if not real_pos or not real_pos.get('short'):
                logger.error(f"‚ùå Short data manquant apr√®s doublement")
                return

            entry_short_moyen = real_pos['short']['entry_price']
            size_short_total = real_pos['short']['size']

            # ‚úÖ 2. Augmenter Fib level (+1)
            position.short_fib_level += 1
            position.entry_price_short = entry_short_moyen
            logger.info(f"   ‚úì Fib level: {position.short_fib_level - 1} ‚Üí {position.short_fib_level}")

            # ‚úÖ 3. Placer NOUVEAU TP Short (0.3% fixe au prix moyen)
            time.sleep(1)
            TP_FIXE = 0.3
            tp_short_price = entry_short_moyen * (1 - TP_FIXE / 100)

            tp_order = self.place_tpsl_order(
                symbol=pair,
                plan_type='profit_plan',
                trigger_price=tp_short_price,
                hold_side='short',
                size=size_short_total
            )
            if tp_order and tp_order.get('id'):
                position.orders['tp_short'] = tp_order['id']
                logger.info(f"   ‚úì Nouveau TP Short @ {self.format_price(tp_short_price, pair)} (-{TP_FIXE}%, {size_short_total:.0f} contrats)")

            # ‚úÖ 4. Placer NOUVEAU Fibo Short (niveau suivant)
            time.sleep(1)
            next_level = position.short_fib_level + 1
            if next_level < len(position.fib_levels):
                next_pct = position.fib_levels[next_level]
                fibo_short_price = entry_short_moyen * (1 + next_pct / 100)

                fibo_order = self.exchange.create_order(
                    symbol=pair, type='limit', side='sell', amount=size_short_total * 2,
                    price=fibo_short_price, params={'tradeSide': 'open', 'holdSide': 'short'}
                )
                if fibo_order and fibo_order.get('id'):
                    position.orders['double_short'] = fibo_order['id']
                    logger.info(f"   ‚úì Nouveau Fibo Short @ {self.format_price(fibo_short_price, pair)} (+{next_pct}%, Fib {next_level})")

            position.short_size_previous = size_short_total

        except Exception as e:
            logger.error(f"‚ùå Erreur handle_fib_short_executed: {e}")
            import traceback
            logger.error(traceback.format_exc())

    # ============================================================================
    # MESSAGES TELEGRAM PAR POSITION
    # ============================================================================

    def send_position_message(self, pair, position):
        """
        Cr√©e et envoie 1 message Telegram par position
        Format: Prix | LONG | SHORT | ORDRES ACTIFS
        """
        try:
            current_price = self.get_price(pair)
            if not current_price:
                return

            real_pos = self.get_real_positions(pair)
            if not real_pos:
                return

            pair_name = pair.split('/')[0]

            # === HEADER ===
            message = f"üìä <b>{pair_name}</b> | üí∞ {self.format_price(current_price, pair)}\n"

            # === LONG ===
            if real_pos.get('long'):
                long_data = real_pos['long']
                message += f"üü¢ LONG | {long_data['size']:.0f} @ {self.format_price(long_data['entry_price'], pair)} | "
                message += f"Marge: {long_data['margin']:.2f} | P&L: {long_data['unrealized_pnl']:+.2f}\n"
            else:
                message += f"üü¢ LONG | Ferm√©\n"

            # === SHORT ===
            if real_pos.get('short'):
                short_data = real_pos['short']
                message += f"üî¥ SHORT | {short_data['size']:.0f} @ {self.format_price(short_data['entry_price'], pair)} | "
                message += f"Marge: {short_data['margin']:.2f} | P&L: {short_data['unrealized_pnl']:+.2f}\n"
            else:
                message += f"üî¥ SHORT | Ferm√©\n"

            # === ORDRES (AFFICHER LES PRIX R√âELS) ===
            message += f"\nüìã <b>Ordres Actifs:</b>\n"

            # R√©cup√©rer les ordres TP/SL R√âELS depuis Bitget
            tpsl_orders = self.get_tpsl_orders(pair)

            # TP Long
            tp_long_found = False
            if position.orders.get('tp_long'):
                for order in tpsl_orders:
                    if order.get('holdSide') == 'long' and order.get('planType') == 'pos_profit':
                        tp_price = float(order.get('triggerPrice', 0))
                        message += f"üéØ TP Long @ {self.format_price(tp_price, pair)} (+0.3%)\n"
                        tp_long_found = True
                        break
            if not tp_long_found:
                message += f"üéØ TP Long | -\n"

            # Fibo Long (Ordre LIMIT)
            fibo_long_found = False
            if position.orders.get('double_long'):
                open_orders = self.exchange.fetch_open_orders(symbol=pair)
                for order in open_orders:
                    if order.get('side') == 'buy' and order.get('type') == 'limit':
                        fibo_price = float(order.get('price', 0))
                        next_pct = position.fib_levels[position.long_fib_level + 1] if position.long_fib_level + 1 < len(position.fib_levels) else 0
                        message += f"üì¶ Fibo Long @ {self.format_price(fibo_price, pair)} (-{next_pct:.2f}%)\n"
                        fibo_long_found = True
                        break
            if not fibo_long_found:
                message += f"üì¶ Fibo Long | -\n"

            # TP Short
            tp_short_found = False
            if position.orders.get('tp_short'):
                for order in tpsl_orders:
                    if order.get('holdSide') == 'short' and order.get('planType') == 'pos_profit':
                        tp_price = float(order.get('triggerPrice', 0))
                        message += f"üéØ TP Short @ {self.format_price(tp_price, pair)} (-0.3%)\n"
                        tp_short_found = True
                        break
            if not tp_short_found:
                message += f"üéØ TP Short | -\n"

            # Fibo Short (Ordre LIMIT)
            fibo_short_found = False
            if position.orders.get('double_short'):
                open_orders = self.exchange.fetch_open_orders(symbol=pair)
                for order in open_orders:
                    if order.get('side') == 'sell' and order.get('type') == 'limit':
                        fibo_price = float(order.get('price', 0))
                        next_pct = position.fib_levels[position.short_fib_level + 1] if position.short_fib_level + 1 < len(position.fib_levels) else 0
                        message += f"üì¶ Fibo Short @ {self.format_price(fibo_price, pair)} (+{next_pct:.2f}%)\n"
                        fibo_short_found = True
                        break
            if not fibo_short_found:
                message += f"üì¶ Fibo Short | -\n"

            message += f"\n‚è∞ {datetime.now().strftime('%H:%M:%S')}"

            self.send_telegram(message)

        except Exception as e:
            logger.error(f"Erreur send_position_message {pair}: {e}")

    def send_all_position_messages(self):
        """Envoie les messages Telegram pour TOUTES les positions"""
        for pair, position in self.active_positions.items():
            self.send_position_message(pair, position)
            time.sleep(0.5)  # Petit d√©lai pour √©viter spam Telegram

    # ============================================================================
    # 4 D√âTECTEURS SIMPLES - C≈ìur de la strat√©gie
    # ============================================================================

    def detect_tp_long_executed(self, pair, position, real_pos):
        """
        D√©tecte si TP Long a √©t√© ex√©cut√©
        Signature SIMPLE: Position LONG DISPARUE = TP touch√©!
        """
        # Si position Long √©tait ouverte AVANT mais n'existe PLUS maintenant = TP ex√©cut√©!
        if position.long_open and not real_pos.get('long'):
            print(f"üî¥ TP LONG D√âTECT√â: Position LONG DISPARUE!")
            logger.info(f"‚úÖ TP Long ex√©cut√©: Position ferm√©e (disparue)")
            return True

        return False

    def detect_tp_short_executed(self, pair, position, real_pos):
        """
        D√©tecte si TP Short a √©t√© ex√©cut√©
        Signature: Marge diminue de >50% OU position ferm√©e
        """
        if not position.short_open or not real_pos.get('short'):
            return False

        short_margin_now = real_pos['short']['margin']

        # Si marge diminue de plus de 50% = TP touch√©
        if position.short_margin_previous > 0:
            margin_decrease_pct = ((position.short_margin_previous - short_margin_now) / position.short_margin_previous) * 100
            if margin_decrease_pct > 50:
                logger.info(f"‚úÖ TP Short ex√©cut√©: marge {position.short_margin_previous:.2f} ‚Üí {short_margin_now:.2f} (-{margin_decrease_pct:.0f}%)")
                return True

        # Mettre √† jour pour prochaine v√©rification
        position.short_margin_previous = short_margin_now
        return False

    def detect_fibo_long_executed(self, pair, position, real_pos):
        """
        D√©tecte si Fibo Limite Long a √©t√© ex√©cut√©
        Signature: Taille augmente de >30%
        """
        if not real_pos.get('long'):
            return False

        long_size_now = real_pos['long']['size']

        # Si taille augmente de plus de 30% = Fibo ex√©cut√©
        if position.long_size_previous > 0:
            size_increase_pct = ((long_size_now - position.long_size_previous) / position.long_size_previous) * 100
            if size_increase_pct > 30:
                logger.info(f"‚úÖ Fibo Long ex√©cut√©: taille {position.long_size_previous:.0f} ‚Üí {long_size_now:.0f} (+{size_increase_pct:.0f}%)")
                return True

        return False

    def detect_fibo_short_executed(self, pair, position, real_pos):
        """
        D√©tecte si Fibo Limite Short a √©t√© ex√©cut√©
        Signature: Taille augmente de >30%
        """
        if not real_pos.get('short'):
            return False

        short_size_now = real_pos['short']['size']

        # Si taille augmente de plus de 30% = Fibo ex√©cut√©
        if position.short_size_previous > 0:
            size_increase_pct = ((short_size_now - position.short_size_previous) / position.short_size_previous) * 100
            if size_increase_pct > 30:
                logger.info(f"‚úÖ Fibo Short ex√©cut√©: taille {position.short_size_previous:.0f} ‚Üí {short_size_now:.0f} (+{size_increase_pct:.0f}%)")
                return True

        return False

    # ============================================================================

    def check_orders_status(self, iteration=0):
        """
        Boucle de d√©tection (chaque 1 seconde)
        D√©tecte les 4 √©v√©nements et d√©clenche les actions
        """

        for pair, position in list(self.active_positions.items()):
            try:
                # R√©cup√©rer l'√©tat R√âEL de l'API
                real_pos = self.get_real_positions(pair)
                if not real_pos:
                    print(f"[{iteration}] ‚ö†Ô∏è get_real_positions retourne None pour {pair}")
                    continue

                # ‚öôÔ∏è INITIALISATION PREMI√àRE IT√âRATION (valeurs _previous √† 0)
                if position.long_margin_previous == 0 and real_pos.get('long'):
                    position.long_margin_previous = real_pos['long']['margin']
                    position.long_size_previous = real_pos['long']['size']
                    print(f"[{iteration}] ‚úì INIT Long margin: {position.long_margin_previous:.4f}")

                if position.short_margin_previous == 0 and real_pos.get('short'):
                    position.short_margin_previous = real_pos['short']['margin']
                    position.short_size_previous = real_pos['short']['size']
                    print(f"[{iteration}] ‚úì INIT Short margin: {position.short_margin_previous:.4f}")

                # ‚úÖ √âV√âNEMENT 1: TP LONG EX√âCUT√â
                tp_long_detected = self.detect_tp_long_executed(pair, position, real_pos)
                if tp_long_detected:
                    print(f"[{iteration}] üî¥üî¥üî¥ TP LONG D√âTECT√â - D√âCLENCHER HANDLER! üî¥üî¥üî¥")
                    self.handle_tp_long_executed(pair, position)
                    time.sleep(1)
                    self.send_position_message(pair, position)  # Message Telegram
                    continue

                # ‚úÖ √âV√âNEMENT 2: TP SHORT EX√âCUT√â
                tp_short_detected = self.detect_tp_short_executed(pair, position, real_pos)
                if tp_short_detected:
                    print(f"[{iteration}] üî¥üî¥üî¥ TP SHORT D√âTECT√â - D√âCLENCHER HANDLER! üî¥üî¥üî¥")
                    self.handle_tp_short_executed(pair, position)
                    time.sleep(1)
                    self.send_position_message(pair, position)  # Message Telegram
                    continue

                # ‚úÖ √âV√âNEMENT 3: FIBO LONG EX√âCUT√â
                fibo_long_detected = self.detect_fibo_long_executed(pair, position, real_pos)
                if fibo_long_detected:
                    print(f"[{iteration}] üü°üü°üü° FIBO LONG D√âTECT√â - D√âCLENCHER HANDLER! üü°üü°üü°")
                    self.handle_fibo_long_executed(pair, position, position.long_size_previous, real_pos['long']['size'])
                    position.long_size_previous = real_pos['long']['size']
                    time.sleep(1)
                    self.send_position_message(pair, position)
                    continue

                # ‚úÖ √âV√âNEMENT 4: FIBO SHORT EX√âCUT√â
                fibo_short_detected = self.detect_fibo_short_executed(pair, position, real_pos)
                if fibo_short_detected:
                    print(f"[{iteration}] üü°üü°üü° FIBO SHORT D√âTECT√â - D√âCLENCHER HANDLER! üü°üü°üü°")
                    self.handle_fibo_short_executed(pair, position, position.short_size_previous, real_pos['short']['size'])
                    position.short_size_previous = real_pos['short']['size']
                    time.sleep(1)
                    self.send_position_message(pair, position)
                    continue

            except Exception as e:
                print(f"‚ùå EXCEPTION check_orders_status {pair}: {e}")
                logger.error(f"Erreur check_orders_status {pair}: {e}")
                import traceback
                logger.error(traceback.format_exc())

    def open_next_hedge(self):
        """Ouvre un nouveau hedge sur la prochaine paire disponible"""
        # V√©rifier si le bot est en pause
        if hasattr(self, 'telegram_commands') and self.telegram_commands.is_paused:
            logger.info("Bot en pause - pas de nouvelle position")
            return

        if self.available_pairs and self.capital_used < self.MAX_CAPITAL:
            next_pair = self.available_pairs[0]
            print(f"\nüîÑ Rotation vers {next_pair}")
            time.sleep(2)
            self.open_hedge_with_limit_orders(next_pair)

    def flash_close_position(self, pair, side):
        """
        Ferme TOUTE une position en utilisant l'endpoint Bitget Flash Close Position
        API: /api/v2/mix/order/close-positions
        Ferme automatiquement 100% de la position, pas besoin de sp√©cifier la quantit√©
        """
        logger.info(f"Flash Close Position: {side.upper()} {pair}")

        try:
            # Convertir symbol au format Bitget
            symbol_bitget = pair.replace('/USDT:USDT', 'USDT').replace('/', '').lower()

            # Endpoint Flash Close Position
            endpoint = '/api/v2/mix/order/close-positions'
            body = {
                'symbol': symbol_bitget,
                'productType': 'USDT-FUTURES',
                'holdSide': side  # 'long' ou 'short'
            }
            body_json = json.dumps(body)

            # Timestamp et signature
            timestamp = str(int(time.time() * 1000))
            signature = self.bitget_sign_request(timestamp, 'POST', endpoint, body_json)

            # Headers
            headers = {
                'ACCESS-KEY': self.api_key,
                'ACCESS-SIGN': signature,
                'ACCESS-TIMESTAMP': timestamp,
                'ACCESS-PASSPHRASE': self.api_password,
                'Content-Type': 'application/json',
                'locale': 'en-US',
                'PAPTRADING': '1'
            }

            # Requ√™te HTTP
            url = f"https://api.bitget.com{endpoint}"
            response = requests.post(url, headers=headers, data=body_json, timeout=10)
            data = response.json()

            if data.get('code') == '00000':
                logger.info(f"‚úÖ Flash Close r√©ussi: {side} {pair}")
                print(f"‚úÖ Position {side} ferm√©e √† 100% (Flash Close)")
                return True
            else:
                logger.error(f"Flash Close √©chou√©: {data}")
                print(f"‚ö†Ô∏è Flash Close r√©ponse: {data}")
                return False

        except Exception as e:
            logger.error(f"Erreur Flash Close: {e}")
            print(f"‚ùå Erreur Flash Close: {e}")
            return False

    def cleanup_all_positions_and_orders(self):
        """
        Nettoie TOUTES les positions et ordres au d√©marrage
        FORCE la fermeture de tout pour garantir une session propre
        """
        logger.info("=== NETTOYAGE COMPLET D√âMARR√â ===")
        print("\n" + "="*50)
        print("üßπ NETTOYAGE FORC√â - FERMETURE DE TOUT")
        print("="*50)
        self.send_telegram("üßπ <b>NETTOYAGE FORC√â EN COURS...</b>\n\n‚ö†Ô∏è Fermeture de TOUTES les positions et ordres")

        cleanup_report = []

        try:
            # 1. FERMER TOUTES LES POSITIONS avec Flash Close API
            logger.info("√âtape 1: Fermeture des positions avec Flash Close API")
            for pair in self.volatile_pairs:
                try:
                    positions = self.exchange.fetch_positions(symbols=[pair])
                    for pos in positions:
                        size = float(pos.get('contracts', 0))
                        if size > 0:
                            side = pos.get('side', '').lower()

                            logger.info(f"Position trouv√©e: {side.upper()} {pair} - {size} contrats")
                            print(f"   üî¥ Fermeture {side.upper()} {pair}: {size} contrats")

                            # UTILISER FLASH CLOSE API (ferme 100% automatiquement)
                            success = self.flash_close_position(pair, side)

                            if success:
                                cleanup_report.append(f"‚úÖ Ferm√© {side.upper()} {pair.split('/')[0]} ({size:.0f} contrats)")

                                # V√©rifier que c'est bien ferm√©
                                time.sleep(2)
                                verify = self.exchange.fetch_positions(symbols=[pair])
                                for vpos in verify:
                                    if vpos.get('side', '').lower() == side:
                                        remaining = float(vpos.get('contracts', 0))
                                        if remaining > 0:
                                            logger.warning(f"‚ö†Ô∏è Flash Close n'a pas tout ferm√©: {remaining} reste")
                                            cleanup_report.append(f"‚ö†Ô∏è {side.upper()} {pair.split('/')[0]}: {remaining} restants")
                                        else:
                                            logger.info(f"‚úÖ V√©rification OK: {side} {pair} ferm√© √† 100%")
                            else:
                                cleanup_report.append(f"‚ùå √âchec fermeture {side.upper()} {pair.split('/')[0]}")
                                logger.error(f"√âchec Flash Close pour {side} {pair}")

                            time.sleep(1)

                except Exception as e:
                    error_msg = f"Erreur fermeture positions {pair}: {e}"
                    logger.error(error_msg)
                    print(f"   ‚ö†Ô∏è  {error_msg}")

            # 2. ANNULER TOUS LES ORDRES LIMITES EN ATTENTE
            for pair in self.volatile_pairs:
                try:
                    # R√©cup√©rer tous les ordres ouverts
                    open_orders = self.exchange.fetch_open_orders(symbol=pair)

                    for order in open_orders:
                        order_id = order['id']
                        print(f"   üóëÔ∏è  Annulation ordre {order['type']} {order['side']} sur {pair}")
                        self.exchange.cancel_order(order_id, pair)
                        cleanup_report.append(f"üóëÔ∏è Annul√© ordre {pair.split('/')[0]}")
                        time.sleep(0.2)

                except Exception as e:
                    print(f"   ‚ö†Ô∏è  Erreur annulation ordres {pair}: {e}")

            # 3. ANNULER TOUS LES ORDRES TP/SL (PLAN ORDERS)
            for pair in self.volatile_pairs:
                try:
                    tpsl_orders = self.get_tpsl_orders(pair)

                    for order in tpsl_orders:
                        order_id = order.get('orderId')
                        plan_type = order.get('planType', '')

                        if order_id:
                            print(f"   üóëÔ∏è  Annulation TP/SL {plan_type} sur {pair}")
                            self.cancel_tpsl_order(order_id, pair)
                            cleanup_report.append(f"üóëÔ∏è Annul√© TP/SL {pair.split('/')[0]}")
                            time.sleep(0.2)

                except Exception as e:
                    print(f"   ‚ö†Ô∏è  Erreur annulation TP/SL {pair}: {e}")

            # 4. R√âINITIALISER LES VARIABLES
            self.active_positions = {}
            self.available_pairs = self.volatile_pairs.copy()
            self.capital_used = 0
            self.total_profit = 0
            self.pnl_history = []
            self.total_fees_paid = 0

            # 5. ENVOYER RAPPORT
            if cleanup_report:
                message = f"""
üßπ <b>NETTOYAGE TERMIN√â</b>

{chr(10).join(cleanup_report[:10])}

‚úÖ Pr√™t pour nouvelle session!

‚è∞ {datetime.now().strftime('%H:%M:%S')}
"""
                self.send_telegram(message)
                print("‚úÖ Nettoyage termin√©!")
            else:
                print("‚úÖ Aucune position/ordre √† nettoyer")
                self.send_telegram("‚úÖ Aucune position/ordre √† nettoyer")

        except Exception as e:
            print(f"‚ùå Erreur pendant le nettoyage: {e}")
            self.send_telegram(f"‚ö†Ô∏è Erreur nettoyage: {e}")

        # V√âRIFICATION FINALE ABSOLUE - S'assurer que TOUT est vraiment ferm√©
        print("\nüîç V√©rification finale apr√®s cleanup...")
        logger.info("V√©rification finale post-cleanup")

        positions_restantes = []
        ordres_restants = []

        for pair in self.volatile_pairs:
            try:
                # V√©rifier positions
                positions = self.exchange.fetch_positions(symbols=[pair])
                for pos in positions:
                    if float(pos.get('contracts', 0)) > 0:
                        side = pos.get('side', '').lower()
                        size = float(pos.get('contracts', 0))
                        positions_restantes.append(f"{side.upper()} {pair}: {size}")
                        logger.error(f"‚ùå POSITION TOUJOURS OUVERTE APR√àS CLEANUP: {side} {pair} - {size} contrats")

                # V√©rifier ordres limites
                open_orders = self.exchange.fetch_open_orders(symbol=pair)
                if open_orders:
                    ordres_restants.append(f"{pair}: {len(open_orders)} ordres")
                    logger.error(f"‚ùå ORDRES TOUJOURS ACTIFS APR√àS CLEANUP: {pair} - {len(open_orders)} ordres")

                # V√©rifier ordres TP/SL
                tpsl = self.get_tpsl_orders(pair)
                if tpsl:
                    ordres_restants.append(f"{pair}: {len(tpsl)} TP/SL")
                    logger.error(f"‚ùå TP/SL TOUJOURS ACTIFS APR√àS CLEANUP: {pair} - {len(tpsl)} ordres")

            except Exception as e:
                logger.error(f"Erreur v√©rification finale {pair}: {e}")

        if positions_restantes or ordres_restants:
            alert_msg = "üö® <b>ALERTE CLEANUP INCOMPLET!</b>\n\n"
            if positions_restantes:
                alert_msg += "‚ùå Positions restantes:\n"
                alert_msg += "\n".join(positions_restantes) + "\n\n"
            if ordres_restants:
                alert_msg += "‚ùå Ordres restants:\n"
                alert_msg += "\n".join(ordres_restants)

            self.send_telegram(alert_msg)
            print("‚ö†Ô∏è ATTENTION: Cleanup incomplet, voir logs")

            # Essayer une deuxi√®me fois plus agressive
            print("üîÑ Tentative de cleanup forc√© suppl√©mentaire...")
            for pair in self.volatile_pairs:
                try:
                    positions = self.exchange.fetch_positions(symbols=[pair])
                    for pos in positions:
                        if float(pos.get('contracts', 0)) > 0:
                            side = pos.get('side', '').lower()
                            self.flash_close_position(pair, side)
                            time.sleep(1)
                except:
                    pass
        else:
            print("‚úÖ V√©rification finale: TOUT est ferm√©!")
            logger.info("‚úÖ Cleanup complet v√©rifi√© - aucune position ni ordre restant")

        # Attendre un peu avant de commencer
        time.sleep(3)

    def perform_health_check(self):
        """
        V√©rification automatique de la sant√© du bot
        V√©rifie l'√©tat API, la coh√©rence des positions, les erreurs
        Envoie un rapport sur Telegram toutes les 60 secondes
        """
        current_time = time.time()

        # Ne v√©rifier que toutes les 60 secondes
        if current_time - self.last_health_check < self.health_check_interval:
            return

        self.last_health_check = current_time

        try:
            logger.info("=== HEALTH CHECK D√âMARR√â ===")
            issues = []
            warnings = []

            # 1. V√âRIFIER CONNEXION API
            try:
                balance = self.exchange.fetch_balance()
                logger.info("‚úÖ API Bitget: OK")
            except Exception as e:
                issues.append(f"‚ùå API Bitget: {str(e)[:50]}")
                logger.error(f"API Error: {e}")
                self.error_count += 1

            # 2. V√âRIFIER COH√âRENCE DES POSITIONS
            for pair in self.volatile_pairs:
                try:
                    real_pos = self.get_real_positions(pair)
                    if real_pos:
                        long_data = real_pos.get('long')
                        short_data = real_pos.get('short')

                        # V√©rifier si hedge √©quilibr√©
                        if long_data and short_data:
                            long_size = long_data['size']
                            short_size = short_data['size']

                            # Note: D√©s√©quilibre NORMAL dans strat√©gie Fibonacci
                            # Une position peut √™tre √† Fib 0 (250) et l'autre √† Fib 3 (6750)
                            # Pas d'alerte n√©cessaire

                        # V√©rifier P&L extr√™me
                        if long_data and abs(long_data.get('unrealized_pnl', 0)) > 50:
                            warnings.append(f"‚ö†Ô∏è {pair.split('/')[0]}: PNL Long √©lev√© (${long_data['unrealized_pnl']:+.2f})")

                        if short_data and abs(short_data.get('unrealized_pnl', 0)) > 50:
                            warnings.append(f"‚ö†Ô∏è {pair.split('/')[0]}: PNL Short √©lev√© (${short_data['unrealized_pnl']:+.2f})")

                except Exception as e:
                    issues.append(f"‚ùå V√©rif {pair.split('/')[0]}: {str(e)[:30]}")
                    logger.error(f"Position check error {pair}: {e}")

            # 3. V√âRIFIER LES ORDRES EN ATTENTE
            total_orders = 0
            for pair in self.volatile_pairs:
                try:
                    open_orders = self.exchange.fetch_open_orders(symbol=pair)
                    total_orders += len(open_orders)
                except:
                    pass

            # 4. CONSTRUIRE RAPPORT D√âTAILL√â AVEC VRAIES DONN√âES API
            if issues:
                # Probl√®mes critiques d√©tect√©s
                message = f"""
üö® <b>ALERTE - Probl√®mes d√©tect√©s</b>

{chr(10).join(issues[:5])}

Erreurs totales: {self.error_count}

‚è∞ {datetime.now().strftime('%H:%M:%S')}
"""
                self.send_telegram(message)
                logger.warning(f"Health check: {len(issues)} issues")

            elif warnings:
                # Avertissements - afficher les vraies donn√©es
                message = f"""
‚ö†Ô∏è <b>Health Check: Avertissements</b>

{chr(10).join(warnings[:5])}

‚è∞ {datetime.now().strftime('%H:%M:%S')}
"""
                self.send_telegram(message)
                logger.info(f"Health check: {len(warnings)} warnings")

            else:
                # Tout va bien - RAPPORT D√âTAILL√â AVEC VRAIES DONN√âES API
                message_parts = ["‚úÖ <b>SYST√àME OK</b>\n"]

                # Parcourir chaque paire active et afficher VRAIES donn√©es
                for pair in self.volatile_pairs:
                    try:
                        real_pos = self.get_real_positions(pair)
                        if not real_pos:
                            continue

                        long_data = real_pos.get('long')
                        short_data = real_pos.get('short')

                        # Si au moins une position existe sur cette paire
                        if long_data or short_data:
                            pair_name = pair.split('/')[0]
                            current_price = self.get_price(pair)

                            message_parts.append(f"\n‚îÅ‚îÅ‚îÅ‚îÅ <b>{pair_name}</b> ‚îÅ‚îÅ‚îÅ‚îÅ")
                            message_parts.append(f"üí∞ Prix: ${current_price:.5f}\n")

                            # LONG (si ouvert) - EN VERT
                            if long_data:
                                contracts = long_data['size']
                                entry = long_data['entry_price']
                                margin = long_data['margin']
                                pnl = long_data['unrealized_pnl']
                                roe = long_data['pnl_percentage']

                                message_parts.append(f"üü¢ <b>LONG</b>")
                                message_parts.append(f"üü¢ Contrats: {contracts:.0f}")
                                message_parts.append(f"üü¢ Entr√©e: ${entry:.5f}")
                                message_parts.append(f"üü¢ Marge: {margin:.7f} USDT")
                                message_parts.append(f"üü¢ P&L: {pnl:+.7f} USDT")
                                message_parts.append(f"üü¢ ROE: {roe:+.2f}%\n")

                            # SHORT (si ouvert) - EN ROUGE
                            if short_data:
                                contracts = short_data['size']
                                entry = short_data['entry_price']
                                margin = short_data['margin']
                                pnl = short_data['unrealized_pnl']
                                roe = short_data['pnl_percentage']
                                liq_price = short_data.get('liquidation_price', 0)

                                message_parts.append(f"üî¥ <b>SHORT</b>")
                                message_parts.append(f"üî¥ Contrats: {contracts:.0f}")
                                message_parts.append(f"üî¥ Entr√©e: ${entry:.5f}")
                                message_parts.append(f"üî¥ Marge: {margin:.7f} USDT")
                                message_parts.append(f"üî¥ P&L: {pnl:+.7f} USDT")
                                message_parts.append(f"üî¥ ROE: {roe:+.2f}%")
                                if liq_price > 0:
                                    message_parts.append(f"üî¥ üíÄ Liq: ${liq_price:.5f}")

                    except Exception as e:
                        logger.error(f"Erreur affichage {pair}: {e}")

                # Footer avec r√©sum√©
                message_parts.append(f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                message_parts.append(f"üìù Ordres: {total_orders}")
                message_parts.append(f"üîß API: OK")
                message_parts.append(f"üêõ Erreurs: {self.error_count}")
                message_parts.append(f"\n‚è∞ {datetime.now().strftime('%H:%M:%S')}")

                self.send_telegram("\n".join(message_parts))
                logger.info("Health check: All OK - Detailed report sent")

                # R√©initialiser le compteur d'erreurs si tout va bien
                if self.error_count > 0:
                    self.error_count = max(0, self.error_count - 1)

            logger.info("=== HEALTH CHECK TERMIN√â ===")

        except Exception as e:
            logger.error(f"Erreur lors du health check: {e}")
            self.send_telegram(f"‚ùå Erreur health check: {e}")

    def send_status_telegram(self):
        """Envoie status d√©taill√© sur Telegram toutes les 60s (1 minute)"""
        current_time = time.time()
        if current_time - self.last_status_update < 60:  # 1 minute
            return

        if not self.active_positions:
            return

        message_parts = ["üìä <b>STATUS POSITIONS</b>\n"]
        total_pnl = 0

        for pair, pos in self.active_positions.items():
            real_pos = self.get_real_positions(pair)
            current_price = self.get_price(pair)

            if not real_pos or not current_price:
                continue

            long_data = real_pos.get('long')
            short_data = real_pos.get('short')

            # En-t√™te de la paire avec prix actuel
            pair_name = pair.split('/')[0]
            pair_msg = f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            pair_msg += f"<b>{pair_name}</b>\n"
            pair_msg += f"üí∞ Prix actuel: {self.format_price(current_price, pair)}\n"

            # LONG (si ouvert)
            if long_data:
                pnl = long_data['unrealized_pnl'] or 0
                total_pnl += pnl
                entry_long = long_data['entry_price']

                # Calcul variation % par rapport au prix d'entr√©e MARKET
                variation_pct = ((current_price - entry_long) / entry_long) * 100

                pair_msg += f"\nüìà <b>LONG</b> (Hedge)\n"
                pair_msg += f"   Entr√©e: {self.format_price(entry_long, pair)}\n"
                pair_msg += f"   Variation: {variation_pct:+.2f}%\n"
                pair_msg += f"   P&L: ${pnl:+.2f} (ROE: {long_data['pnl_percentage']:+.1f}%)\n"

                # Afficher TP
                next_trigger = pos.get_next_long_trigger_pct()
                if next_trigger:
                    next_price = long_data['entry_price'] * (1 + next_trigger / 100)
                    pair_msg += f"   üéØ TP: {self.format_price(next_price, pair)} (+{next_trigger}%, Fib {pos.long_fib_level + 1})\n"

            # SHORT (si ouvert)
            if short_data:
                pnl = short_data['unrealized_pnl'] or 0
                total_pnl += pnl
                entry_short = short_data['entry_price']

                # Calcul variation % par rapport au prix d'entr√©e MARKET
                variation_pct = ((current_price - entry_short) / entry_short) * 100

                pair_msg += f"\nüìâ <b>SHORT</b> (Hedge)\n"
                pair_msg += f"   Entr√©e: {self.format_price(entry_short, pair)}\n"
                pair_msg += f"   Variation: {variation_pct:+.2f}%\n"
                pair_msg += f"   P&L: ${pnl:+.2f} (ROE: {short_data['pnl_percentage']:+.1f}%)\n"
                pair_msg += f"   üíÄ Liq: {self.format_price(short_data['liquidation_price'], pair)}\n"

                # Afficher TP
                next_trigger = pos.get_next_short_trigger_pct()
                if next_trigger:
                    next_price = short_data['entry_price'] * (1 - next_trigger / 100)
                    pair_msg += f"   üéØ TP: {self.format_price(next_price, pair)} (-{next_trigger}%, Fib {pos.short_fib_level + 1})\n"

            message_parts.append(pair_msg)

        # R√©cup√©rer les frais totaux
        total_fees = self.get_total_fees()
        self.total_fees_paid = total_fees

        # Footer avec balance et frais
        balance_available = self.MAX_CAPITAL - self.capital_used
        usage_pct = (self.capital_used / self.MAX_CAPITAL * 100)
        pnl_net = total_pnl + self.total_profit - total_fees

        message_parts.append(f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        message_parts.append(f"\nüí∞ P&L Total: ${total_pnl + self.total_profit:+.2f}")
        message_parts.append(f"\nüí∏ Frais pay√©s: ${total_fees:.2f}")
        message_parts.append(f"\nüíé <b>P&L Net: ${pnl_net:+.2f}</b>")
        message_parts.append(f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        message_parts.append(f"\nüìä Positions: {len(self.active_positions)}")
        message_parts.append(f"\nüíµ Balance: ${balance_available:.0f}‚Ç¨ / ${self.MAX_CAPITAL:.0f}‚Ç¨ ({usage_pct:.1f}% utilis√©)")
        message_parts.append(f"\n‚è∞ {datetime.now().strftime('%H:%M:%S')}")

        self.send_telegram("".join(message_parts))
        self.last_status_update = current_time

    def restore_positions_from_api(self):
        """Restaure les positions actives depuis l'API apr√®s un restart"""
        try:
            logger.info("Restauration positions depuis API...")
            print("\nüîÑ Restauration des positions depuis l'API...")

            # Parcourir toutes les paires volatiles
            for pair in self.volatile_pairs:
                real_pos = self.get_real_positions(pair)
                if real_pos and (real_pos.get('long') or real_pos.get('short')):
                    # Extraire prix d'entr√©e
                    entry_long = real_pos['long']['entry_price'] if real_pos.get('long') else 0
                    entry_short = real_pos['short']['entry_price'] if real_pos.get('short') else 0

                    # Cr√©er HedgePosition avec bons param√®tres
                    position = HedgePosition(pair, self.INITIAL_MARGIN, entry_long, entry_short)

                    # Restaurer √©tats et tailles
                    if real_pos.get('long'):
                        position.long_open = True
                        position.long_size_previous = real_pos['long']['size']
                        logger.info(f"LONG restaur√©: {position.long_size_previous:.0f} contrats @ ${entry_long:.5f}")
                    else:
                        position.long_open = False

                    if real_pos.get('short'):
                        position.short_open = True
                        position.short_size_previous = real_pos['short']['size']
                        logger.info(f"SHORT restaur√©: {position.short_size_previous:.0f} contrats @ ${entry_short:.5f}")
                    else:
                        position.short_open = False

                    # Ajouter aux positions actives
                    self.active_positions[pair] = position
                    print(f"   ‚úÖ {pair.split('/')[0]}: LONG={position.long_open}, SHORT={position.short_open}")

                    # Note: Les ordres (TP, double) ne sont pas restaur√©s ici
                    # Ils seront recr√©√©s lors du prochain cycle si n√©cessaire

            if self.active_positions:
                logger.info(f"{len(self.active_positions)} positions restaur√©es")
                print(f"\n‚úÖ {len(self.active_positions)} positions restaur√©es\n")
            else:
                logger.info("Aucune position √† restaurer")
                print("‚ÑπÔ∏è  Aucune position active trouv√©e\n")

        except Exception as e:
            logger.error(f"Erreur restauration positions: {e}")
            print(f"‚ö†Ô∏è  Erreur restauration: {e}")

    def run(self):
        """Boucle principale"""
        print("="*80)
        print("üöÄ BITGET HEDGE BOT V2 - ORDRES LIMITES AUTO")
        print("="*80)

        # Message Telegram imm√©diat (avant Bitget)
        startup_test = f"""
üöÄ <b>BOT D√âMARRAGE</b>

üåê Oracle Cloud: ‚úÖ
üêç Python: ‚úÖ
üì± Telegram: {'‚úÖ' if self.telegram_token else '‚ùå'}
üîë Bitget API: {'‚úÖ' if self.api_key else '‚ùå'}

‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        self.send_telegram(startup_test)

        if not self.api_key:
            print("‚ùå Cl√©s API manquantes")
            self.send_telegram("‚ùå Cl√©s API Bitget manquantes!")
            return

        try:
            print("\nüì° Connexion Bitget Testnet...")
            self.exchange.load_markets()

            # TOUJOURS NETTOYER au d√©marrage (session propre)
            logger.info("Nettoyage complet au d√©marrage")
            print("\nüßπ Nettoyage de toutes les positions et ordres...")
            self.cleanup_all_positions_and_orders()

            # Attendre que le cleanup soit bien termin√©
            print("‚è≥ Attente finalisation cleanup (5 secondes)...")
            time.sleep(5)

            # MAINTENANT d√©marrer le monitoring des anomalies
            logger.info("D√©marrage du monitoring des anomalies")
            self.telegram_commands.start_monitoring()

            # Message d√©marrage
            startup = f"""
ü§ñ <b>CRYPTO HEDGE BOT V2 D√âMARR√â</b>

üí∞ Capital: ${self.MAX_CAPITAL}‚Ç¨
‚ö° Levier: x{self.LEVERAGE}
üìä Marge initiale: ${self.INITIAL_MARGIN}‚Ç¨

üìù <b>Syst√®me:</b>
‚úÖ Hedge automatique avec TP/SL
‚úÖ Grille Fibonacci adaptive
‚úÖ Nettoyage auto au d√©marrage
‚úÖ V√©rification sant√© toutes les 60s
‚úÖ Logs d√©taill√©s sauvegard√©s

ü™ô Paires: {', '.join([p.split('/')[0] for p in self.volatile_pairs])}

üì≤ <b>Commandes:</b>
/pnl /positions /balance /history
/status /logs /admin /help

üîÑ <b>Contr√¥le √† distance:</b>
/update - Mise √† jour GitHub
/restart - Red√©marrage
/stop - Arr√™t s√©curis√©

üõ°Ô∏è Health Check: V√©rifie API, positions, ordres
üìä Rapport syst√®me: Toutes les 60 secondes
üåê Serveur: Oracle Cloud (Marseille)

‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            self.send_telegram(startup)

            # Ouvrir hedge sur DOGE (session propre)
            logger.info(f"Ouverture hedge DOGE")
            print(f"\nüìä Ouverture hedge DOGE...")

            test_pair = 'DOGE/USDT:USDT'
            if test_pair in self.available_pairs:
                success = self.open_hedge_with_limit_orders(test_pair)
                if success:
                    logger.info(f"‚úÖ Hedge DOGE ouvert")
                    print(f"‚úÖ Hedge DOGE ouvert avec succ√®s")
                else:
                    logger.error(f"‚ùå √âchec ouverture hedge DOGE")
            else:
                logger.error(f"DOGE/USDT:USDT pas disponible!")

            # NE PAS ouvrir PEPE ni SHIB (mode test)
            # pairs_to_open = self.available_pairs.copy()
            # for idx, pair in enumerate(pairs_to_open):
            #     if self.capital_used >= self.MAX_CAPITAL:
            #         logger.warning(f"Capital max atteint, arr√™t ouverture √† {idx} paires")
            #         break
            #
            #     logger.info(f"Ouverture hedge {idx+1}/{len(pairs_to_open)}: {pair}")
            #     success = self.open_hedge_with_limit_orders(pair)
            #
            #     if success and idx < len(pairs_to_open) - 1:
            #         # Attendre 3s entre chaque ouverture
            #         logger.info(f"Attente 3s avant prochaine paire...")
            #         time.sleep(3)

            # Boucle
            iteration = 0
            last_pulse_time = time.time()

            while True:
                loop_start = time.time()

                # ‚úÖ PRIORIT√â 1: D√âTECTION TP/FIBO (CRITIQUE - CHAQUE SECONDE)
                self.check_orders_status(iteration)

                # ‚úÖ PRIORIT√â 2: COMMANDES TELEGRAM (toutes les 2 secondes)
                if iteration % 2 == 0:
                    self.check_telegram_commands()

                # ‚úÖ PRIORIT√â 3: HEALTH CHECK (toutes les 60 secondes)
                if iteration % 60 == 0:
                    self.perform_health_check()

                # üîÑ PULSE: Confirmation API appel√©e (toutes les 10 secondes)
                if time.time() - last_pulse_time >= 10:
                    last_pulse_time = time.time()
                    pulse_msg = f"üîÑ <b>API Pulse OK</b>\n"
                    pulse_msg += f"‚è∞ {datetime.now().strftime('%H:%M:%S')}\n"
                    pulse_msg += f"üìä It√©ration: {iteration}\n"
                    pulse_msg += f"üìç Positions actives: {len(self.active_positions)}\n"

                    # Compter les ordres totaux
                    total_orders = 0
                    for pos in self.active_positions.values():
                        total_orders += sum(1 for o in pos.orders.values() if o)
                    pulse_msg += f"üìã Ordres: {total_orders}"

                    self.send_telegram(pulse_msg)
                    logger.info(f"üîÑ Pulse: It√©ration {iteration}, {len(self.active_positions)} positions, {total_orders} ordres")

                # üìä DEBUG: Afficher prix en temps r√©el (toutes les 30 secondes seulement)
                if iteration % 30 == 0 and self.active_positions:
                    print(f"\n{'='*80}")
                    print(f"üîç DEBUG - It√©ration {iteration} - {datetime.now().strftime('%H:%M:%S')}")
                    print(f"{'='*80}")

                    for pair, position in self.active_positions.items():
                        current_price = self.get_price(pair)
                        if not current_price:
                            continue

                        print(f"\nüìä {pair}")
                        print(f"   Prix actuel: {self.format_price(current_price, pair)}")

                        # Long (si ouvert)
                        if position.long_open:
                            entry_long = position.entry_price_long
                            change_pct = ((current_price - entry_long) / entry_long) * 100
                            next_trigger = position.get_next_long_trigger_pct()

                            print(f"   üìà LONG (Fib {position.long_fib_level}):")
                            print(f"      Prix entr√©e: {self.format_price(entry_long, pair)}")
                            print(f"      Variation: {change_pct:+.4f}%")
                            if next_trigger:
                                print(f"      Trigger TP: +{next_trigger}% (Fib {position.long_fib_level + 1})")
                                print(f"      Distance trigger: {(next_trigger - change_pct):.4f}%")

                        # Short (si ouvert)
                        if position.short_open and position.entry_price_short > 0:
                            entry_short = position.entry_price_short
                            change_pct = ((current_price - entry_short) / entry_short) * 100
                            next_trigger = position.get_next_short_trigger_pct()

                            print(f"   üìâ SHORT (Fib {position.short_fib_level}):")
                            print(f"      Prix entr√©e: {self.format_price(entry_short, pair)}")
                            print(f"      Variation: {change_pct:+.4f}%")
                            if next_trigger:
                                print(f"      Trigger TP: -{next_trigger}% (Fib {position.short_fib_level + 1})")
                                print(f"      Distance trigger: {(abs(change_pct) - next_trigger):.4f}%")

                    print(f"\nüìä {len(self.active_positions)} positions actives | Capital: ${self.capital_used}/${self.MAX_CAPITAL}")

                iteration += 1

                # ‚è±Ô∏è Assurer une it√©ration par seconde exacte
                loop_time = time.time() - loop_start
                sleep_time = max(0.1, 1.0 - loop_time)  # Min 0.1s pour √©viter CPU 100%
                time.sleep(sleep_time)

        except KeyboardInterrupt:
            print("\n‚úã Arr√™t")
            self.send_telegram("üõë Bot arr√™t√©")
            raise  # Propager pour que main() sache que c'est un arr√™t manuel
        except Exception as e:
            print(f"‚ùå Erreur dans run(): {e}")
            import traceback
            logger.error(f"Exception dans run(): {traceback.format_exc()}")
            self.send_telegram(f"‚ùå Erreur d√©tect√©e: {str(e)[:150]}")
            raise  # Propager l'erreur vers main() pour red√©marrage auto


def main():
    """Fonction principale - manage_local.sh g√®re les red√©marrages"""
    try:
        bot = BitgetHedgeBotV2()
        bot.run()
    except KeyboardInterrupt:
        print("\n‚úã Arr√™t manuel du bot (Ctrl+C)")
        try:
            bot.send_telegram("üõë Bot arr√™t√© manuellement (Ctrl+C)")
        except:
            pass
    except SystemExit:
        # /restart ou /stop appel√© - laisser manage_local.sh g√©rer
        print("\nüîÑ Sortie normale (commande admin)")
    except Exception as e:
        # Erreur critique - logger et quitter
        error_msg = f"‚ùå ERREUR CRITIQUE: {str(e)[:200]}"
        print(f"\n{error_msg}")
        import traceback
        logger.error(f"Erreur critique:")
        logger.error(traceback.format_exc())

        try:
            temp_bot = BitgetHedgeBotV2()
            temp_bot.send_telegram(f"‚ùå BOT CRASH\n\n{str(e)[:150]}\n\n‚è∞ {datetime.now().strftime('%H:%M:%S')}")
        except:
            pass
        raise  # Re-lever l'erreur pour que le process se termine


if __name__ == "__main__":
    main()
